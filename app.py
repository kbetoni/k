# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lSTkoXFw57BsoQQd4cHxlclYQOvJM7cG
"""

import streamlit as st
import openai
import pdfplumber
import pandas as pd
import re
import unicodedata
from openpyxl.styles import Font, Alignment
import tempfile

st.set_page_config(page_title="An√°lise Autom√°tica de Propostas de Bombas", layout="wide")


# =================== FUN√á√ïES DE EXTRA√á√ÉO E PROMPTS ===================
def extrair_texto_pdf(file):
    texto_total = ""
    with pdfplumber.open(file) as pdf:
        for pagina in pdf.pages:
            texto = pagina.extract_text()
            if texto:
                texto_total += texto + "\n"
    return texto_total

def prompt_lote1(texto_extraido):
    return f"""
A partir do texto extra√≠do, extraia os seguintes dados da lista abaixo. A lista apresenta o nome da vari√°vel, o termo correspondente da vari√°vel no texto extraido em par√™nteses e a unidade da vari√°vel (caso o dado possuia unidade). Em alguns casos, o dado vir√° como "informar", nesses casos o valor extraido dever√° ser "informar", assim como descrito no texto extraido.

- Fluido Bombeado (**Liquid type**).
- Caracter√≠stica do Fluido (**Additional liquid description**).
- Densidade do Fluido (**Fluid density**): Em kg/m3.
- Viscosidade (**Viscosity, rated**): Em cp.
- Press√£o de Vapor (**Vapor pressure, rated**): Em bar.a.
- Di√¢metro da maior part√≠cula s√≥lida (**Solids diameter, max**): Em mm.
- Concentra√ß√£o de s√≥lidos por volume (**Solids concentration, by volume**): Em %.
- Temperatura de Opera√ß√£o (**Temperature, rated**): Em ¬∞C.
- Temperatura M√°xima de Opera√ß√£o (**Temperature, max**): Em ¬∞C.
- Frequ√™ncia Dispon√≠vel no Campo (**Site Supply Frequency**): Em Hz.
- Vaz√£o de Opera√ß√£o (**Flow, rated**): Em m¬≥/h.
- Vaz√£o M√≠nima Cont√≠nua Est√°vel (**MCSF**): Em m3/h.
- Vaz√£o no BEP (**Flow, best eff. Point**): Em m¬≥/h.
- NPSH Dispon√≠vel (**NPSH available,rated**): Em m.
- NPSH Requerido (**NPSH (3% head drop)**): Em m.

Retorne TODOS os par√¢metros da lista, nesta ordem, mesmo se n√£o forem encontrados (coloque "N√£o encontrado").
Use os nomes exatos da lista para a coluna 'Descri√ß√£o'. N√£o pule NENHUM item.
O texto extra√≠do do PDF √©:
{texto_extraido}

| Descri√ß√£o                          | Valor | Unidade |
|------------------------------------|-------|---------|
| Fluido Bombeado                    |       |    -    |
| Caracter√≠stica do Fluido           |       |    -    |
| Densidade do Fluido                |       | kg/m¬≥   |
| Viscosidade                        |       | cP      |
| Press√£o de Vapor                   |       | bar.a   |
| Di√¢metro da maior part√≠cula s√≥lida |       | mm      |
| Concentra√ß√£o de s√≥lidos por volume |       | %       |
| Temperatura de Opera√ß√£o            |       | ¬∞C      |
| Temperatura M√°xima de Opera√ß√£o     |       | ¬∞C      |
| Frequ√™ncia Dispon√≠vel no Campo     |       | Hz      |
| Vaz√£o de Opera√ß√£o                  |       | m¬≥/h    |
| Vaz√£o M√≠nima Cont√≠nua Est√°vel      |       | m¬≥/h    |
| Vaz√£o no BEP                       |       | m¬≥/h    |
| NPSH Dispon√≠vel                    |       | m       |
| NPSH Requerido                     |       | m       |
"""

def prompt_lote2(texto_extraido):
    return f"""
A partir do texto extra√≠do, extraia os seguintes dados da lista abaixo. A lista apresenta o nome da vari√°vel, o termo correspondente da vari√°vel no texto extraido em par√™nteses e a unidade da vari√°vel (caso o dado possua unidade). Em alguns casos, o dado vir√° como "informar", nesses casos o valor extraido dever√° ser "informar", assim como descrito no texto extraido.

- AMT de Projeto (**Diferential Head, rated**): Em m.
- AMT do Rotor M√°ximo na Vaz√£o de Projeto (**Head, maximum, rated diameter**): Em m.
- Margem de Shut-Off (**Head rise to shutoff**): %.
- M√°xima Press√£o de Opera√ß√£o da Voluta (**Maximum casing/bowl working pressure**): Em bar.g.
- M√°xima Press√£o de Opera√ß√£o admiss√≠vel (**Maximum allowable working pressure**): Em bar.g.
- M√°xima Press√£o de Suc√ß√£o admiss√≠vel (**Maximum allowable suction pressure**): Em kg.cm2.g.
- Pess√£o do Teste Hidrost√°tico (**Hydrostatic test pressure**): Em bar.g.
- Press√£o de Suc√ß√£o (**Suction Pressure**): Em kg/cm2.g.
- Press√£o de Descarga de Opera√ß√£o (**Discharge Pressure, rated**): Em bar.g.
- Press√£o Diferencial de Opera√ß√£o (**Differential pressure, rated**): Em bar.g.
- Rota√ß√£o Constante ou Vari√°vel (**Fixed / Vabiable Speed**).
- Rota√ß√£o do Motor (**Speed, driver, rated**):Em rpm.
- Rota√ß√£o Selecionada (**Speed, rated**): Em rpm.
- Di√¢metro M√≠nimo do Rotor (**Impeller diameter, minimum**): Em mm.
- Di√¢metro M√°ximo do Rotor (**Impeller diameter, maximum**): Em mm.

Retorne TODOS os par√¢metros da lista, nesta ordem, mesmo se n√£o forem encontrados (coloque "N√£o encontrado").
Use os nomes exatos da lista para a coluna 'Descri√ß√£o'. N√£o pule NENHUM item.
O texto extra√≠do do PDF √©:
{texto_extraido}

| Descri√ß√£o                          | Valor | Unidade |
|------------------------------------|-------|---------|
| AMT de Projeto                     |       | m       |
| AMT do Rotor M√°ximo na Vaz√£o de Projeto |       | m    |
| Margem de Shut-Off                 |       | %       |
| M√°xima Press√£o de Opera√ß√£o da Voluta |       | bar.g   |
| M√°xima Press√£o de Opera√ß√£o admiss√≠vel|       | bar.g   |
| M√°xima Press√£o de Suc√ß√£o admiss√≠vel |       | kg.cm2.g |
| Pess√£o do Teste Hidrost√°tico       |       | bar.g   |
| Press√£o de Suc√ß√£o                  |       | kg.cm2.g |
| Press√£o de Descarga de Opera√ß√£o    |       | bar.g   |
| Press√£o Diferencial de Opera√ß√£o    |       | bar.g   |
| Rota√ß√£o Constante ou Vari√°vel      |       |  -      |
| Rota√ß√£o do Motor                   |       | rpm     |
| Rota√ß√£o Selecionada                |       | rpm     |
| Di√¢metro M√≠nimo do Rotor           |       | mm      |
| Di√¢metro M√°ximo do Rotor           |       | mm      |
"""

def prompt_lote3(texto_extraido):
    return f"""
A partir do texto extra√≠do, extraia os seguintes dados da lista abaixo. A lista apresenta o nome da vari√°vel, o termo correspondente da vari√°vel no texto extraido em par√™nteses e a unidade da vari√°vel (caso o dado possua unidade). Em alguns casos, o dado vir√° como "informar", nesses casos o valor extraido dever√° ser "informar", assim como descrito no texto extraido.

- Di√¢metro Selecionado do Rotor (**Impeller diameter, rated**): Em mm.
- Efici√™ncia da Bomba (**Efficiency**): Em %.
- Modelo de Bomba (**Pump Type**).
- Caracter√≠sticas adicionais da bomba (**Additional Pump Description**).
- Comprimento do Conjunto (**Length**): Em mm.
- Largura do Conjunto (**Width**): Em mm.
- Altura do Conjunto (**Hight**): Em mm.
- Di√¢metro do Bocal de Suc√ß√£o (**Suction Nozzle Size**): Em mm.
- Di√¢metro do Bocal de Descarga (**Discharge Nozzle Size**): Em mm.
- Material da Carca√ßa (**Case / bowls**).
- Material do Rotor (**Impeller**).
- Material dos Aneis de Desgaste (**Case / Impeller Wear Rings**).
- Material do Eixo (**Shaft**).
- Tipo de Acoplamento (**Coupling**).
- Tipo de Motor (**Driver**).

Retorne TODOS os par√¢metros da lista, nesta ordem, mesmo se n√£o forem encontrados (coloque "N√£o encontrado").
Use os nomes exatos da lista para a coluna 'Descri√ß√£o'. N√£o pule NENHUM item.
O texto extra√≠do do PDF √©:
{texto_extraido}

| Descri√ß√£o                          | Valor | Unidade |
|------------------------------------|-------|---------|
| Di√¢metro Selecionado do Rotor      |       | mm      |
| Efici√™ncia da Bomba                |       |  %      |
| Modelo de Bomba                    |       | -       |
| Caracter√≠sticas adicionais da bomba|       | -       |
| Comprimento do Conjunto            |       | mm      |
| Largura do Conjunto                |       | mm      |
| Altura do Conjunto                 |       | mm      |
| Di√¢metro do Bocal de Suc√ß√£o        |       | mm      |
| Di√¢metro do Bocal de Descarga      |       | mm      |
| Material da Carca√ßa                |       | -       |
| Material do Rotor                  |       | -       |
| Material dos Aneis de Desgaste     |       | -       |
| Material do Eixo                   |       | -       |
| Tipo de Acoplamento                |       | -       |
| Tipo de Motor                      |       | -       |
"""

def prompt_lote4(texto_extraido):
    return f"""
A partir do texto extra√≠do, extraia os seguintes dados da lista abaixo. Em alguns casos, o dado vir√° como "informar", nesses casos o valor extraido dever√° ser "informar", assim como descrito no texto extraido.

- Tens√£o do Motor (**Volts**): Em V.
- Fase do Motor (**Phase**).
- Frequ√™ncia do Motor (**Frequency**): Em Hz.
- Pot√™ncia Hidr√°ulica (**Power, hydraulic**): Em kW.
- Pot√™ncia Instalada (**Driver size**): Em kW.
- Pot√™ncia Consumida (**Power, rated**): Em kW.
- Pot√™ncia Absorvida (BHP) (**Power, maximum, rated diameter**): Em kW.
- Fator de Servi√ßo (**Service Factor**).
- Grau de prote√ß√£o (**Enclosure**).
- Peso da Bomba (**Pump**): Em kg.
- Peso do motor (**Driver**): Em kg.
- Peso da Base (**Baseplate**): Em kg.
- Peso do Conjunto (**Total Package**): Em kg.
- Pre√ßo (**Pump Price**): Em R$.
- Prazo de Entrega (**Estimated Delivery**): Em Dias

Retorne TODOS os par√¢metros da lista, nesta ordem, mesmo se n√£o forem encontrados (coloque "N√£o encontrado").
Use os nomes exatos da lista para a coluna 'Descri√ß√£o'. N√£o pule NENHUM item.
O texto extra√≠do do PDF √©:
{texto_extraido}

| Descri√ß√£o                          | Valor | Unidade |
|------------------------------------|-------|---------|
| Tens√£o do Motor                    |       | V       |
| Fase do Motor                      |       | -       |
| Frequ√™ncia do Motor                |       | Hz      |
| Pot√™ncia Hidr√°ulica                |       | kW      |
| Pot√™ncia Instalada                 |       | kW      |
| Pot√™ncia Consumida                 |       | kW      |
| Pot√™ncia Absorvida (BHP)           |       | kW      |
| Fator de Servi√ßo                   |       | -       |
| Grau de prote√ß√£o                   |       | -       |
| Peso da Bomba                      |       | kg      |
| Peso do motor                      |       | kg      |
| Peso da Base                       |       | kg      |
| Peso do Conjunto                   |       | kg      |
| Pre√ßo                              |       | R$      |
| Prazo de Entrega                   |       | Dias    |
"""

def analisar_texto_com_openai(texto_extraido):
    try:
        resposta_parte1 = openai.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "Voc√™ √© um assistente t√©cnico especializado em an√°lise de propostas de bombas."},
                {"role": "user", "content": prompt_lote1(texto_extraido)}
            ],
            max_tokens=800,
            temperature=0
        )
        resposta_parte2 = openai.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "Voc√™ √© um assistente t√©cnico especializado em an√°lise de propostas de bombas."},
                {"role": "user", "content": prompt_lote2(texto_extraido)}
            ],
            max_tokens=800,
            temperature=0
        )
        resposta_parte3 = openai.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "Voc√™ √© um assistente t√©cnico especializado em an√°lise de propostas de bombas."},
                {"role": "user", "content": prompt_lote3(texto_extraido)}
            ],
            max_tokens=800,
            temperature=0
        )
        resposta_parte4 = openai.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "Voc√™ √© um assistente t√©cnico especializado em an√°lise de propostas de bombas."},
                {"role": "user", "content": prompt_lote4(texto_extraido)}
            ],
            max_tokens=800,
            temperature=0
        )
        dados_completos = (
            resposta_parte1.choices[0].message.content.strip() + "\n" +
            resposta_parte2.choices[0].message.content.strip() + "\n" +
            resposta_parte3.choices[0].message.content.strip() + "\n" +
            resposta_parte4.choices[0].message.content.strip()
        )
        return dados_completos
    except Exception as e:
        st.error(f"Erro ao processar texto com OpenAI: {e}")
        return "Erro na an√°lise com OpenAI"

# -- PADRONIZA√á√ïES B√ÅSICAS (s√≥ os essenciais para rodar) --
def padronizar_nome(descricao):
    PADRONIZAR = {
        "densidade do fluido": "Densidade do Fluido",
        "pot√™ncia instalada": "Pot√™ncia Instalada",
        "vaz√£o m√≠nima cont√≠nua est√°vel": "Vaz√£o M√≠nima Cont√≠nua Est√°vel",
        # Inclua outras varia√ß√µes conforme aparecerem
    }
    return PADRONIZAR.get(descricao.strip(), descricao.strip())

def padronizar_unidade(unidade):
    PADRONIZAR_UNIDADE = {
        "kg/m3": "kg/m¬≥",
        "kg / m3": "kg/m¬≥",
        "kg/m¬≥": "kg/m¬≥",
        "cp": "cP",
        "bar.a": "bar.a",
        "m3/h": "m¬≥/h",
        "m¬≥/h": "m¬≥/h",
        "bar": "bar",
        "rpm": "rpm",
        "mm": "mm",
        "kW": "kW",
        "%": "%",
        "-": "-",
    }
    return PADRONIZAR_UNIDADE.get(unidade.strip().replace(" ", ""), unidade.strip())

def normalizar(texto):
    texto = str(texto).strip().lower()
    texto = ''.join(c for c in unicodedata.normalize('NFD', texto) if unicodedata.category(c) != 'Mn')
    texto = re.sub(r'[^a-z0-9]', '', texto)
    return texto

# -- CONVERTE A TABELA MARKDOWN PARA DATAFRAME --
def converter_markdown_em_df(markdown_str):
    linhas = markdown_str.strip().split("\n")
    dataframes = []
    tabela_atual = []
    is_table_header = False
    for linha in linhas:
        if linha.strip().startswith("| Descri√ß√£o") and "Valor" in linha and "Unidade" in linha:
            if tabela_atual:
                df_temp = criar_df_de_tabela(tabela_atual)
                if not df_temp.empty:
                    dataframes.append(df_temp)
                tabela_atual = []
            is_table_header = True
            tabela_atual.append(linha)
        elif is_table_header and re.match(r"^\|[- ]+\|[- ]+\|[- ]+\|$", linha.strip()):
            tabela_atual.append(linha)
        else:
            if "|" in linha:
                tabela_atual.append(linha)
    if tabela_atual:
        df_temp = criar_df_de_tabela(tabela_atual)
        if not df_temp.empty:
            dataframes.append(df_temp)
    if dataframes:
        df_final = pd.concat(dataframes, ignore_index=True)
        return df_final
    else:
        return pd.DataFrame()

def criar_df_de_tabela(linhas_tabela):
    if len(linhas_tabela) < 3:
        return pd.DataFrame()
    data_rows = []
    for row in linhas_tabela[2:]:
        partes = [p.strip() for p in row.split("|") if p.strip()]
        if len(partes) == 3:
            data_rows.append({
                "Descri√ß√£o": partes[0],
                "Valor": partes[1],
                "Unidade": partes[2]
            })
    if data_rows:
        return pd.DataFrame(data_rows)
    else:
        return pd.DataFrame()

# -- PR√â-PROCESSAMENTO DE CADA FORNECEDOR --
def processar_fornecedor(nome_arquivo, texto_extraido):
    dados_estruturados = analisar_texto_com_openai(texto_extraido)
    df_bruto = converter_markdown_em_df(dados_estruturados)
    df_bruto.columns = [c.strip().capitalize() for c in df_bruto.columns]
    if "Descri√ß√£o" in df_bruto.columns and "Unidade" in df_bruto.columns and "Valor" in df_bruto.columns:
        df_bruto["Descri√ß√£o"] = df_bruto["Descri√ß√£o"].apply(lambda x: padronizar_nome(x.strip()))
        df_bruto["Unidade"] = df_bruto["Unidade"].apply(lambda x: padronizar_unidade(x.strip()))
        df_bruto["_desc_cmp"] = df_bruto["Descri√ß√£o"].apply(normalizar)
        df_bruto["_und_cmp"] = df_bruto["Unidade"].apply(normalizar)
        df_bruto = df_bruto.drop_duplicates(subset=["_desc_cmp", "_und_cmp"], keep="first")
        df_bruto = df_bruto.drop(columns=["_desc_cmp", "_und_cmp"])
        df_bruto = df_bruto.set_index(["Descri√ß√£o", "Unidade"])[["Valor"]]
        df_bruto.columns = [nome_arquivo]
        return df_bruto
    else:
        st.warning(f"[ERRO] Colunas esperadas n√£o encontradas no DataFrame de {nome_arquivo}: {df_bruto.columns}")
        return None

def montar_tabela_com_secoes_multifornecedor(df, ordem_total=None, map_para_secao=None):
    if map_para_secao is None:
        map_para_secao = {
            "Fluido Bombeado": "DADOS DO FLUIDO",
            "Caracter√≠stica do Fluido": "DADOS DO FLUIDO",
            "Densidade do Fluido": "DADOS DO FLUIDO",
            "Viscosidade": "DADOS DO FLUIDO",
            "Press√£o de Vapor": "DADOS DO FLUIDO",
            "Di√¢metro da maior part√≠cula s√≥lida": "DADOS DO FLUIDO",
            "Concentra√ß√£o de s√≥lidos por volume": "DADOS DO FLUIDO",
            "Frequ√™ncia Dispon√≠vel no Campo": "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO",
            "Temperatura de Opera√ß√£o": "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO",
            "Temperatura M√°xima de Opera√ß√£o": "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO",
            "Press√£o de Descarga de Opera√ß√£o": "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO",
            "Vaz√£o de Opera√ß√£o": "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO",
            "AMT de Projeto": "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO",
            "Vaz√£o no BEP": "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO",
            "Vaz√£o M√≠nima Cont√≠nua Est√°vel": "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO",
            "NPSH Dispon√≠vel": "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO",
            "NPSH Requerido": "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO",
            "Press√£o de Suc√ß√£o": "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO",
            "Press√£o Diferencial de Opera√ß√£o": "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO",
            "M√°xima Press√£o de Suc√ß√£o admiss√≠vel": "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO",
            "M√°xima Press√£o de Opera√ß√£o admiss√≠vel": "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO",
            "M√°xima Press√£o de Opera√ß√£o da Voluta": "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO",
            "Pess√£o do Teste Hidrost√°tico": "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO",
            "Margem de Shut-Off": "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO",
            "Rota√ß√£o Constante ou Vari√°vel": "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO",
            "Rota√ß√£o do Motor": "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO",
            "Rota√ß√£o Selecionada": "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO",
            "Di√¢metro Selecionado do Rotor": "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO",
            "Di√¢metro M√≠nimo do Rotor": "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO",
            "Di√¢metro M√°ximo do Rotor": "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO",
            "AMT do Rotor M√°ximo na Vaz√£o de Projeto": "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO",
            "Efici√™ncia da Bomba": "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO",
            "Modelo de Bomba": "CARACTER√çSTICAS CONSTRUTIVAS",
            "Comprimento do Conjunto": "CARACTER√çSTICAS CONSTRUTIVAS",
            "Caracter√≠sticas adicionais da bomba": "CARACTER√çSTICAS CONSTRUTIVAS",
            "Largura do Conjunto": "CARACTER√çSTICAS CONSTRUTIVAS",
            "Altura do Conjunto": "CARACTER√çSTICAS CONSTRUTIVAS",
            "Di√¢metro do Bocal de Suc√ß√£o": "CARACTER√çSTICAS CONSTRUTIVAS",
            "Di√¢metro do Bocal de Descarga": "CARACTER√çSTICAS CONSTRUTIVAS",
            "Tipo de Motor": "MOTOR EL√âTRICO",
            "Fator de Servi√ßo": "MOTOR EL√âTRICO",
            "Tens√£o do Motor": "MOTOR EL√âTRICO",
            "Fase do Motor": "MOTOR EL√âTRICO",
            "Frequ√™ncia do Motor": "MOTOR EL√âTRICO",
            "Pot√™ncia Hidr√°ulica": "MOTOR EL√âTRICO",
            "Pot√™ncia Consumida": "MOTOR EL√âTRICO",
            "Pot√™ncia Instalada": "MOTOR EL√âTRICO",
            "Pot√™ncia Absorvida (BHP)": "MOTOR EL√âTRICO",
            "Grau de prote√ß√£o": "MOTOR EL√âTRICO",
            "Tipo de Acoplamento": "TRANSMISS√ÉO",
            "Material da Carca√ßa": "MATERIAL DE CONSTRU√á√ÉO",
            "Material do Rotor": "MATERIAL DE CONSTRU√á√ÉO",
            "Material dos Aneis de Desgaste": "MATERIAL DE CONSTRU√á√ÉO",
            "Material do Eixo": "MATERIAL DE CONSTRU√á√ÉO",
            "Peso da Bomba": "PESOS",
            "Peso do motor": "PESOS",
            "Peso da Base": "PESOS",
            "Peso do Conjunto": "PESOS",
            "Pre√ßo": "FINANCEIRO",
            "Prazo de Entrega": "FINANCEIRO"
        }
    secoes = [
        "DADOS DO FLUIDO",
        "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO",
        "CARACTER√çSTICAS CONSTRUTIVAS",
        "MATERIAL DE CONSTRU√á√ÉO",
        "TRANSMISS√ÉO",
        "MOTOR EL√âTRICO",
        "PESOS",
        "FINANCEIRO"
    ]
    col_base = ['Descri√ß√£o', 'Unidade']
    col_forn = [c for c in df.columns if c not in col_base]
    linhas_finais = []
    for secao in secoes:
        linhas_finais.append([secao, '', *['']*len(col_forn)])
        for idx, row in df.iterrows():
            desc = row['Descri√ß√£o']
            if map_para_secao.get(desc) == secao:
                valores = row.tolist()
                linhas_finais.append(valores)
    return pd.DataFrame(linhas_finais, columns=col_base + col_forn)

# ======================================
#  FUN√á√ÉO PARA SALVAR EM EXCEL COM FORMATA√á√ÉO
# ======================================
def salvar_em_excel_formatado(df_final, nome_arquivo_excel="dados_extraidos.xlsx"):
    with pd.ExcelWriter(nome_arquivo_excel, engine="openpyxl") as writer:
        df_final.to_excel(writer, index=False, sheet_name="Dados")
        workbook = writer.book
        worksheet = writer.sheets["Dados"]
        secoes = ["DADOS DO FLUIDO", "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO", "CARACTER√çSTICAS CONSTRUTIVAS",
                  "MATERIAL DE CONSTRU√á√ÉO", "TRANSMISS√ÉO", "MOTOR EL√âTRICO", "PESOS", "FINANCEIRO"]
        for row in worksheet.iter_rows(min_row=2, max_row=worksheet.max_row, min_col=1, max_col=3):
            cell = row[0]
            if cell.value in secoes:
                worksheet.merge_cells(start_row=cell.row, start_column=1, end_row=cell.row, end_column=3)
                cell.font = Font(bold=True)
                cell.alignment = Alignment(horizontal="center", vertical="center")
    return nome_arquivo_excel

def salvar_em_excel_final(dados_estruturados):
    df_bruto = converter_markdown_em_df(dados_estruturados)
    df_bruto.columns = [c.strip().capitalize() for c in df_bruto.columns]
    print(f"\nColunas do DataFrame extra√≠do ({nome_arquivo}):", df_bruto.columns)
    if df_bruto.empty:
        print("N√£o foi poss√≠vel converter as tabelas retornadas em DataFrame.")
        print(dados_estruturados)
        return
    df_final = montar_tabela_com_secoes(df_bruto)
    if not df_final.empty:
        salvar_em_excel_formatado(df_final)
    else:
        print("O DataFrame final est√° vazio. Verifique se os par√¢metros foram encontrados.")

def is_number(s):
    try:
        # Troca v√≠rgula por ponto, remove espa√ßos
        return float(str(s).replace(",", ".").replace(" ", ""))
    except:
        return None

def checar_atendimento(df, col_requisitado):
    cols = list(df.columns)
    colunas_proponentes = [col for col in cols if col not in ["Descri√ß√£o", "Unidade", col_requisitado]]

    # Lista com nomes das se√ß√µes (os t√≠tulos)
    secoes = [
        "DADOS DO FLUIDO",
        "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO",
        "CARACTER√çSTICAS CONSTRUTIVAS",
        "MATERIAL DE CONSTRU√á√ÉO",
        "TRANSMISS√ÉO",
        "MOTOR EL√âTRICO",
        "PESOS",
        "FINANCEIRO"
    ]

    for col_prop in colunas_proponentes:
        col_check = f"Atendimento {col_prop}"
        resultados = []
        for i, row in df.iterrows():
            # Pula linha se for se√ß√£o/t√≠tulo
            if row["Descri√ß√£o"] in secoes:
                resultados.append("")
                continue

            req = str(row[col_requisitado]).strip().lower()
            prop = str(row[col_prop]).strip().lower()
            if req == "informar":
                resultados.append("NA")
                continue

            req_num = is_number(req)
            prop_num = is_number(prop)
            if (req_num is not None) and (prop_num is not None):
                if abs(req_num - prop_num) < 1e-6:
                    resultados.append("OK")
                else:
                    resultados.append("NOK")
            else:
                if req == prop:
                    resultados.append("OK")
                elif req.replace(",", ".").replace(" ", "") == prop.replace(",", ".").replace(" ", ""):
                    resultados.append("OK")
                else:
                    resultados.append("NOK")
        df[col_check] = resultados
    return df

# ======================================
#  FUN√á√ÉO PARA AVALIAR PROPONENTES
# ======================================


def relatorio_analitico_fornecedores(df_final, col_requisitado):
    secoes = [
        "DADOS DO FLUIDO", "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO", "CARACTER√çSTICAS CONSTRUTIVAS",
        "MATERIAL DE CONSTRU√á√ÉO", "TRANSMISS√ÉO", "MOTOR EL√âTRICO", "PESOS", "FINANCEIRO"
    ]
    fornecedores = [
        col for col in df_final.columns
        if col not in ["Descri√ß√£o", "Unidade", col_requisitado] and not col.startswith("Atendimento")
    ]
    relatorios = {}
    desclassificados = []

    def valor(desc, col):
        try:
            return str(df_final.loc[df_final['Descri√ß√£o'] == desc, col].values[0]).strip()
        except:
            return ""

    # 1. NPSH: Desclassifica√ß√£o e compara√ß√£o com margem
    npsh_req = valor("NPSH Requerido", col_requisitado)
    npsh_req_num = is_number(npsh_req)
    margem_npsh = 1.0  # valor em metros

    for f in fornecedores:
        npsh = valor("NPSH Dispon√≠vel", f)
        npsh_num = is_number(npsh)
        if npsh_num is not None and npsh_req_num is not None:
            if npsh_num < npsh_req_num + margem_npsh:
                desclassificados.append((f, f"NPSH dispon√≠vel inferior ao requerido + margem de seguran√ßa ({margem_npsh} m); risco de cavita√ß√£o."))

    classificados = [f for f in fornecedores if f not in [d[0] for d in desclassificados]]


    # 2. Reprova bombas sem acoplamento magn√©tico caso haja s√≥lidos no fluido
    concentracao_solidos = valor("Concentra√ß√£o de s√≥lidos por volume", col_requisitado)
    diametro_solido = valor("Di√¢metro da maior part√≠cula s√≥lida", col_requisitado)

    # Considera s√≥lidos presentes se concentra√ß√£o > 0 ou di√¢metro > 0
    solidos_presentes = False
    try:
        conc = float(str(concentracao_solidos).replace(",", "."))
        diam = float(str(diametro_solido).replace(",", "."))
        solidos_presentes = (conc > 0) or (diam > 0)
    except:
        pass

    for f in classificados[:]:  # Copia da lista para evitar problemas ao remover
        acoplamento = valor("Tipo de Acoplamento", f).lower()
        if solidos_presentes and ("magn√©t" not in acoplamento):
            desclassificados.append((f, "Proposta n√£o possui acoplamento magn√©tico, obrigat√≥rio devido √† presen√ßa de s√≥lidos no fluido."))
            classificados.remove(f)

    # 2. Relat√≥rio anal√≠tico
    for f in fornecedores:
        rel = []
        if f in [d[0] for d in desclassificados]:
            motivo = [motivo for ff, motivo in desclassificados if ff == f][0]
            rel.append(f"**Desclassificado:** {motivo}")
            relatorios[f] = rel
            continue

        # Pot√™ncia instalada >= Pot√™ncia absorvida (BHP)
        pot_inst = is_number(valor("Pot√™ncia Instalada", f))
        pot_bhp = is_number(valor("Pot√™ncia Absorvida (BHP)", f))
        if pot_inst is not None and pot_bhp is not None:
            if pot_inst < pot_bhp:
                rel.append("‚ö†Ô∏è Pot√™ncia instalada inferior √† absorvida. Isso pode resultar em sobrecarga e falha do motor. **Recomenda-se revisar para evitar riscos operacionais.**")
            else:
                rel.append("‚úîÔ∏è Pot√™ncia instalada atende √† absorvida.")
        else:
            rel.append("‚ö†Ô∏è Pot√™ncia instalada ou absorvida n√£o informada. **Verifique se os dados est√£o completos para garantir dimensionamento adequado.**")

        # Efici√™ncia
        eficiencia = is_number(valor("Efici√™ncia da Bomba", f))
        ef_max = max([is_number(valor("Efici√™ncia da Bomba", ff)) for ff in classificados if is_number(valor("Efici√™ncia da Bomba", ff)) is not None] or [0])
        if eficiencia is not None:
            if eficiencia == ef_max:
                rel.append(f"‚úîÔ∏è Maior efici√™ncia ({eficiencia}%).")
            elif eficiencia > 0:
                rel.append(f"Efici√™ncia: {eficiencia}% (menor que a m√°xima: {ef_max}%). **Considere o impacto no consumo energ√©tico da planta.**")
            else:
                rel.append("‚ö†Ô∏è Efici√™ncia n√£o informada. **A efici√™ncia influencia diretamente o custo operacional.**")

        # Escorregamento motor el√©trico
        rot_selecionada = is_number(valor("Rota√ß√£o Selecionada", f))
        rot_motor = is_number(valor("Rota√ß√£o do Motor", f))
        if rot_selecionada and rot_motor:
            if rot_selecionada >= rot_motor:
                rel.append("‚ö†Ô∏è A rota√ß√£o selecionada da bomba √© igual ou superior √† rota√ß√£o do motor. Isso indica aus√™ncia de margem de escorregamento, podendo causar perda de torque e opera√ß√£o inadequada do motor el√©trico de indu√ß√£o. **Recomenda-se sempre especificar rota√ß√£o da bomba inferior √† do motor (por exemplo, motor: 1800 rpm, bomba: 1745 rpm).**")

        # Material de constru√ß√£o
        material = valor("Material da Carca√ßa", f).lower()
        if any(sub in material for sub in ["ferro fundido", "cast iron"]):
            rel.append("‚ö†Ô∏è Bomba apresenta ferro fundido: esse material pode ser suscet√≠vel √† corros√£o dependendo do fluido bombeado. **Avalie a compatibilidade com o processo e o risco de falha prematura.**")
        elif any(sub in material for sub in ["carbon steel", "a√ßo carbono"]):
            rel.append("‚ö†Ô∏è Bomba apresenta a√ßo carbono: pode ser propenso √† corros√£o em ambientes agressivos. **Verifique se a sele√ß√£o do material est√° adequada ao fluido.**")
        elif material == "" or material is None:
            rel.append("‚ö†Ô∏è Material da carca√ßa n√£o informado. **A aus√™ncia dessa informa√ß√£o dificulta a avalia√ß√£o de durabilidade e riscos.**")

        # Acoplamento magn√©tico / selo / gaxeta
        MAP_ACOPLAMENTO = {
            "mechanical seal": "selo mec√¢nico",
            "seal": "selo mec√¢nico",
            "selo mec√¢nico": "selo mec√¢nico",
            "selo mecanico": "selo mec√¢nico",
            "gaxeta": "gaxeta",
            "packing": "gaxeta",
            "magnetic coupling": "acoplamento magn√©tico",
            "acoplamento magn√©tico": "acoplamento magn√©tico",
            "magnetico": "acoplamento magn√©tico",
            "direct": "acoplamento direto",
            "direct coupling": "acoplamento direto",
        }

        def padronizar_acoplamento(valor):
            valor_norm = valor.lower().strip()
            for k in MAP_ACOPLAMENTO:
                if k in valor_norm:
                    return MAP_ACOPLAMENTO[k]
            return valor_norm  # Se n√£o encontrar, retorna o original normalizado

        # No trecho de gera√ß√£o dos alertas:
        acoplamento_raw = valor("Tipo de Acoplamento", f)
        acoplamento = padronizar_acoplamento(acoplamento_raw)

        if acoplamento == "acoplamento magn√©tico":
            rel.append("‚úîÔ∏è Acoplamento magn√©tico: solu√ß√£o recomendada para aplica√ß√µes cr√≠ticas, especialmente em fluidos t√≥xicos, caros ou com s√≥lidos. **Garante estanqueidade e reduz manuten√ß√£o.**")
        elif acoplamento == "selo mec√¢nico":
            rel.append("‚ö†Ô∏è Selo mec√¢nico: op√ß√£o intermedi√°ria. **Pode exigir manuten√ß√£o peri√≥dica e deve ser avaliado quanto √† adequa√ß√£o ao tipo de fluido e presen√ßa de s√≥lidos.**")
        elif acoplamento == "gaxeta":
            rel.append("‚ö†Ô∏è Utiliza gaxetas: esse sistema pode permitir vazamentos e exige manuten√ß√£o frequente. **Recomenda-se avaliar riscos de seguran√ßa, ambientais e de custo operacional.**")
        elif acoplamento:  # N√£o vazio, mas desconhecido
            rel.append(f"‚ö†Ô∏è Tipo de acoplamento n√£o usual: {acoplamento_raw}. **Verifique se atende aos requisitos de confiabilidade e manuten√ß√£o da planta.**")
        else:
            rel.append("‚ö†Ô∏è Tipo de acoplamento n√£o informado. **Essa informa√ß√£o √© essencial para avaliar riscos de opera√ß√£o e manuten√ß√£o.**")

        # Pre√ßo da bomba
        preco = is_number(valor("Pre√ßo", f))
        if preco is not None:
            menores = [is_number(valor("Pre√ßo", ff)) for ff in classificados if is_number(valor("Pre√ßo", ff)) is not None]
            if preco == min(menores):
                rel.append("‚úîÔ∏è Pre√ßo mais barato.")
            elif preco == max(menores):
                rel.append("‚ö†Ô∏è Pre√ßo mais caro. **Avalie se os diferenciais t√©cnicos justificam o investimento maior.**")
        else:
            rel.append("‚ö†Ô∏è Pre√ßo n√£o informado. **A aus√™ncia desse dado impede a an√°lise de custo-benef√≠cio.**")

        # Prazo de entrega
        prazo = is_number(valor("Prazo de Entrega", f))
        menores_prazo = [is_number(valor("Prazo de Entrega", ff)) for ff in classificados if is_number(valor("Prazo de Entrega", ff)) is not None]
        if prazo is not None:
            if prazo == min(menores_prazo):
                rel.append("‚úîÔ∏è Menor prazo de entrega.")
            elif prazo == max(menores_prazo):
                rel.append("‚ö†Ô∏è Maior prazo de entrega. **Considere o impacto no cronograma do projeto.**")
        else:
            rel.append("‚ö†Ô∏è Prazo de entrega n√£o informado. **Verifique para garantir que atenda aos requisitos do projeto.**")

        # Frequ√™ncia local vs motor
        freq_local = is_number(valor("Frequ√™ncia Dispon√≠vel no Campo", col_requisitado))
        freq_motor = is_number(valor("Frequ√™ncia do Motor", f))
        if freq_local and freq_motor:
            if freq_local == freq_motor:
                rel.append("‚úîÔ∏è Frequ√™ncia do motor compat√≠vel com o local.")
            else:
                rel.append(f"‚ö†Ô∏è Frequ√™ncia do motor ({freq_motor}) diferente da dispon√≠vel no local ({freq_local}). **Isso pode impedir o funcionamento adequado do equipamento. Avalie a necessidade de ajustes.**")
        else:
            rel.append("‚ö†Ô∏è Frequ√™ncia do motor/local n√£o informada. **Verifique essa compatibilidade para evitar problemas de partida e funcionamento.**")

        # Vaz√£o opera√ß√£o/BEP entre 0,8 e 1,1
        vazao_op = is_number(valor("Vaz√£o de Opera√ß√£o", f))
        vazao_bep = is_number(valor("Vaz√£o no BEP", f))
        if vazao_op and vazao_bep:
            relacao = vazao_op / vazao_bep
            if 0.8 <= relacao <= 1.1:
                rel.append(f"‚úîÔ∏è Rela√ß√£o vaz√£o de opera√ß√£o/BEP adequada ({relacao:.2f}).")
            else:
                rel.append(f"‚ö†Ô∏è Rela√ß√£o vaz√£o/BEP fora do ideal ({relacao:.2f}). **Operar distante do BEP pode causar vibra√ß√£o, ru√≠do e desgaste prematuro. Avalie o impacto para seu processo.**")
        else:
            rel.append("‚ö†Ô∏è Vaz√£o de opera√ß√£o ou BEP n√£o informada. **Imposs√≠vel avaliar o ponto de opera√ß√£o √≥timo.**")

       # An√°lise do volume do conjunto (menor volume √© positivo)
        def volume_conjunto(f):
            try:
                comp = is_number(valor("Comprimento do Conjunto", f))
                larg = is_number(valor("Largura do Conjunto", f))
                alt = is_number(valor("Altura do Conjunto", f))
                if comp and larg and alt:
                    return comp * larg * alt
            except:
                pass
            return None

        # Calcule volumes para todos os fornecedores
        volumes = {ff: volume_conjunto(ff) for ff in fornecedores if volume_conjunto(ff) is not None}
        if volumes and f in volumes:
            if volumes[f] == min(volumes.values()):
                rel.append("‚úîÔ∏è Equipamento mais compacto (menor volume total). **Facilita a instala√ß√£o, reduz o espa√ßo ocupado na planta e pode simplificar o layout.**")
            elif volumes[f] == max(volumes.values()):
                rel.append("‚ö†Ô∏è Equipamento de maior volume entre as propostas. **Pode dificultar a integra√ß√£o ao layout existente e aumentar custos indiretos de infraestrutura.**")


        # An√°lise do peso do conjunto (menor peso √© positivo)
        pesos = {ff: is_number(valor("Peso do Conjunto", ff)) for ff in fornecedores if is_number(valor("Peso do Conjunto", ff)) is not None}
        if pesos and f in pesos:
            if pesos[f] == min(pesos.values()):
                rel.append("‚úîÔ∏è Equipamento mais leve. **Pode facilitar o transporte, i√ßamento e instala√ß√£o, al√©m de reduzir esfor√ßos na estrutura de suporte.**")
            elif pesos[f] == max(pesos.values()):
                rel.append("‚ö†Ô∏è Equipamento mais pesado entre as propostas. **Exige aten√ß√£o √† estrutura de suporte e pode aumentar custos log√≠sticos.**")

        # Vaz√£o m√≠nima cont√≠nua est√°vel
        vazao_min_req = is_number(valor("Vaz√£o M√≠nima Cont√≠nua Est√°vel", col_requisitado))
        vazao_min = is_number(valor("Vaz√£o M√≠nima Cont√≠nua Est√°vel", f))
        if vazao_min_req and vazao_min:
            if vazao_min <= vazao_min_req:
                rel.append("‚úîÔ∏è Vaz√£o m√≠nima cont√≠nua atende ao especificado.")
            else:
                rel.append("‚ö†Ô∏è Vaz√£o m√≠nima cont√≠nua superior ao especificado. **Pode dificultar a opera√ß√£o em baixas vaz√µes. Avalie riscos de superaquecimento ou cavita√ß√£o.**")
        elif vazao_min is None:
            rel.append("‚ö†Ô∏è Vaz√£o m√≠nima cont√≠nua n√£o informada. **Importante verificar para garantir opera√ß√£o segura em baixa carga.**")

        # Margem de shut-off (em %)
        shut_off = is_number(valor("Margem de Shut-Off", f))
        if shut_off:
            if 10 <= shut_off <= 20:
                rel.append("‚úîÔ∏è Margem de shut-off adequada (10-20%).")
            else:
                rel.append(f"‚ö†Ô∏è Margem de shut-off fora do ideal ({shut_off}%). **Margem inadequada pode aumentar o risco de sobrepress√£o ou limitar o range operacional.**")
        else:
            rel.append("‚ö†Ô∏è Margem de shut-off n√£o informada. **Imposs√≠vel avaliar flexibilidade e seguran√ßa contra sobrepress√£o.**")

        # Materiais dos componentes principais
        for comp, desc in [("Material do Rotor", "rotor"), ("Material do Eixo", "eixo"), ("Material dos Aneis de Desgaste", "an√©is de desgaste")]:
            material = valor(comp, f).lower()
            if any(m in material for m in ["inox", "stainless", "duplex", "bronze"]):
                continue  # N√£o faz alerta se for nobre
            elif any(m in material for m in ["ferro fundido", "cast iron", "carbon steel", "a√ßo carbono"]):
                rel.append(f"‚ö†Ô∏è {desc.title()} com material propenso √† corros√£o ({material}). **Avalie a durabilidade em fun√ß√£o do fluido e ambiente de opera√ß√£o.**")
            elif not material:
                rel.append(f"‚ö†Ô∏è Material do {desc} n√£o informado. **Dificulta a avalia√ß√£o de vida √∫til e confiabilidade.**")

        # Flexibilidade de opera√ß√£o
        velocidade = valor("Rota√ß√£o Constante ou Vari√°vel", f).lower()
        if "variable" in velocidade or "vari√°vel" in velocidade:
            rel.append("‚úîÔ∏è Flexibilidade de opera√ß√£o: utiliza inversor de frequ√™ncia. **Permite ajuste fino do ponto de opera√ß√£o, facilitando adapta√ß√£o a varia√ß√µes de demanda.**")
        elif "fixed" in velocidade or "constante" in velocidade:
            rel.append("‚ö†Ô∏è Velocidade fixa: n√£o utiliza inversor de frequ√™ncia. **Isso reduz a flexibilidade operacional, pois a bomba s√≥ pode trabalhar em um ponto de opera√ß√£o. Avalie se a opera√ß√£o em diferentes regimes √© necess√°ria no seu processo.**")
        elif not velocidade:
            rel.append("‚ö†Ô∏è Informa√ß√£o de velocidade vari√°vel/constante n√£o encontrada. **Verifique essa caracter√≠stica para entender a capacidade de ajuste operacional.**")

        # AMT rotor m√°ximo/AMT projeto > 1,10
        amt_max = is_number(valor("AMT do Rotor M√°ximo na Vaz√£o de Projeto", f))
        amt_proj = is_number(valor("AMT de Projeto", f))
        if amt_max and amt_proj:
            relacao = amt_max / amt_proj
            if relacao > 1.10:
                rel.append(f"‚úîÔ∏è AMT m√°ximo/AMT projeto = {relacao:.2f} (>1,10). **Boa margem para ajustes futuros e usinagem de rotor.**")
            else:
                rel.append(f"‚ö†Ô∏è AMT m√°ximo/AMT projeto abaixo do ideal ({relacao:.2f}). **Pode limitar a capacidade de ajuste do ponto de opera√ß√£o no futuro.**")
        else:
            rel.append("‚ö†Ô∏è AMT m√°ximo ou de projeto n√£o informado. **Verifique para avaliar a flexibilidade de opera√ß√£o.**")

        # Pot√™ncia Instalada/Pot√™ncia Consumida = Fator de servi√ßo
        pot_cons = is_number(valor("Pot√™ncia Consumida", f))
        fator_serv = is_number(valor("Fator de Servi√ßo", f))
        if pot_inst and pot_cons and fator_serv:
            relacao = pot_inst / pot_cons
            if abs(relacao - fator_serv) < 0.05:
                rel.append(f"‚úîÔ∏è Pot√™ncia instalada/consumida ‚âà Fator de servi√ßo ({relacao:.2f}).")
            else:
                rel.append(f"‚ö†Ô∏è Pot√™ncia instalada/consumida ({relacao:.2f}) diferente do fator de servi√ßo especificado ({fator_serv}). **Reveja para garantir margem de seguran√ßa adequada.**")
        else:
            rel.append("‚ö†Ô∏è Pot√™ncia instalada, consumida ou fator de servi√ßo n√£o informado. **Verifique todos os par√¢metros para validar o dimensionamento el√©trico.**")

        # Tipo de motor
        tipo_motor = valor("Tipo de Motor", f).lower()
        if "combust√£o" in tipo_motor or "diesel" in tipo_motor or "gasolina" in tipo_motor or "combustion" in tipo_motor:
            rel.append("‚ö†Ô∏è Motor a combust√£o: s√≥ √© recomendado para bombas de inc√™ndio. **Avalie se h√° justificativa t√©cnica para uso em outras aplica√ß√µes.**")

        # Identifique a op√ß√£o com menor pot√™ncia consumida
        potencias = {ff: is_number(valor("Pot√™ncia Consumida", ff)) for ff in fornecedores if is_number(valor("Pot√™ncia Consumida", ff)) is not None}
        if potencias and f in potencias:
            if potencias[f] == min(potencias.values()):
                rel.append("‚úîÔ∏è Menor consumo de energia el√©trica. **Pode resultar em menor custo operacional ao longo do tempo.**")

        relatorios[f] = rel

    # Pr√©-sele√ß√£o final: s√≥ classificados, priorizando efici√™ncia, prazo, pre√ßo, etc.
    pre_selecionados = [f for f in classificados][:3]

    return relatorios, desclassificados, pre_selecionados

# Para exibir relat√≥rio
def imprimir_relatorio(relatorios, desclassificados, pre_selecionados):
    print("\n====== RELAT√ìRIO ANAL√çTICO DOS FORNECEDORES ======\n")
    for f, pontos in relatorios.items():
        positivos = []
        negativos = []
        for ponto in pontos:
            # Ajuste os crit√©rios de acordo com seus √≠cones/frases
            if ponto.startswith("‚úîÔ∏è") or ponto.startswith("‚úÖ") or "menor consumo" in ponto.lower() or "maior efici√™ncia" in ponto.lower() or "pre√ßo mais barato" in ponto.lower() or "menor prazo" in ponto.lower() or "pot√™ncia instalada atende" in ponto.lower():
                positivos.append(ponto)
            else:
                negativos.append(ponto)
        print(f"\nFornecedor: {f}")
        # Primeiro pontos positivos
        for p in positivos:
            print(" -", p)
        # Depois pontos negativos
        for p in negativos:
            print(" -", p)
    print("\n**Desclassificados:**")
    for f, motivo in desclassificados:
        print(f" - {f}: {motivo}")
    print("\n**Pr√©-selecionados:**", ", ".join(pre_selecionados))

# Salvar relat√≥rio em txt

def salvar_relatorio_txt(relatorios, desclassificados, pre_selecionados, filename="relatorio_analitico.txt"):
    with open(filename, "w", encoding="utf-8") as f:
        f.write("====== RELAT√ìRIO ANAL√çTICO DOS FORNECEDORES ======\n\n")
        for fornecedor, pontos in relatorios.items():
            positivos = []
            negativos = []
            for ponto in pontos:
                if ponto.startswith("‚úîÔ∏è") or ponto.startswith("‚úÖ") or "menor consumo" in ponto.lower() or "maior efici√™ncia" in ponto.lower() or "pre√ßo mais barato" in ponto.lower() or "menor prazo" in ponto.lower() or "pot√™ncia instalada atende" in ponto.lower():
                    positivos.append(ponto)
                else:
                    negativos.append(ponto)
            f.write(f"Fornecedor: {fornecedor}\n")
            for p in positivos:
                f.write(f" - {p}\n")
            for p in negativos:
                f.write(f" - {p}\n")
            f.write("\n")
        f.write("**Desclassificados:**\n")
        for fdesc, motivo in desclassificados:
            f.write(f" - {fdesc}: {motivo}\n")
        f.write("\n**Pr√©-selecionados:** " + ", ".join(pre_selecionados) + "\n")
    print(f"Relat√≥rio salvo em {filename}")


# =================== APP PRINCIPAL ===================
def main():
    st.title("An√°lise Inteligente de Propostas de Bombas")
    st.write("Fa√ßa upload dos PDFs de propostas e receba a planilha comparativa com relat√≥rio anal√≠tico.")

    openai_key = st.sidebar.text_input("API Key da OpenAI (gpt-4)", type="password")
    uploaded_files = st.file_uploader("Selecione os arquivos PDF das propostas", type=["pdf"], accept_multiple_files=True)

    if not openai_key:
        st.warning("Insira sua API Key da OpenAI para continuar.", icon="‚ö†Ô∏è")
        st.stop()
    openai.api_key = openai_key

    if uploaded_files:
        st.info("Processando PDFs...", icon="üîÑ")
        dfs_fornecedores = []
        nomes_fornecedores = []
        nome_arquivo_requisitado = None
        for file in uploaded_files:
            nome_arquivo = file.name.replace(".pdf", "")
            texto_extraido = extrair_texto_pdf(file)
            with st.expander(f"Texto extra√≠do de {nome_arquivo}"):
                st.write(texto_extraido)
            df_fornecedor = processar_fornecedor(nome_arquivo, texto_extraido)
            if df_fornecedor is not None:
                dfs_fornecedores.append(df_fornecedor)
                nomes_fornecedores.append(nome_arquivo)
                if nome_arquivo.lower() == "requisitado":
                    nome_arquivo_requisitado = nome_arquivo

        if dfs_fornecedores:
            df_final = pd.concat(dfs_fornecedores, axis=1)
            df_final = df_final.reset_index()
            st.dataframe(df_final)

            st.subheader("Baixe a tabela Excel final:")
            nome_arquivo_excel = "dados_extraidos.xlsx"
            with pd.ExcelWriter(nome_arquivo_excel, engine="openpyxl") as writer:
                df_final.to_excel(writer, index=False, sheet_name="Dados")
                workbook = writer.book
                worksheet = writer.sheets["Dados"]
                secoes = [
                    "DADOS DO FLUIDO", "CONDI√á√ïES DE OPERA√á√ÉO E DESEMPENHO",
                    "CARACTER√çSTICAS CONSTRUTIVAS", "MATERIAL DE CONSTRU√á√ÉO",
                    "TRANSMISS√ÉO", "MOTOR EL√âTRICO", "PESOS", "FINANCEIRO"
                ]
                for row in worksheet.iter_rows(min_row=2, max_row=worksheet.max_row, min_col=1, max_col=3):
                    cell = row[0]
                    if cell.value in secoes:
                        worksheet.merge_cells(start_row=cell.row, start_column=1, end_row=cell.row, end_column=3)
                        cell.font = Font(bold=True)
                        cell.alignment = Alignment(horizontal="center", vertical="center")
            with open(nome_arquivo_excel, "rb") as f:
                st.download_button("Baixar Excel formatado", data=f, file_name=nome_arquivo_excel)

            # ===== Relat√≥rio Anal√≠tico =====
            st.subheader("Relat√≥rio Anal√≠tico T√©cnico")
            if not nome_arquivo_requisitado:
                nome_arquivo_requisitado = nomes_fornecedores[0]  # fallback

            col_requisitado = nome_arquivo_requisitado
            if st.button("Gerar Relat√≥rio Anal√≠tico"):
                df_final2 = checar_atendimento(df_final, col_requisitado=col_requisitado)
                relatorios, desclassificados, pre_selecionados = relatorio_analitico_fornecedores(df_final2, col_requisitado)
                for f, pontos in relatorios.items():
                    st.markdown(f"**Fornecedor: {f}**")
                    for p in pontos:
                        if p.startswith("‚úîÔ∏è"):
                            st.success(p)
                        elif p.startswith("‚ö†Ô∏è"):
                            st.warning(p)
                        else:
                            st.write(p)
                if desclassificados:
                    st.warning("**Desclassificados:**")
                    for f, motivo in desclassificados:
                        st.write(f"- {f}: {motivo}")
                if pre_selecionados:
                    st.info("**Pr√©-selecionados:** " + ", ".join(pre_selecionados))

                with tempfile.NamedTemporaryFile("w+", delete=False, suffix=".txt", encoding="utf-8") as temp_file:
                    salvar_relatorio_txt(relatorios, desclassificados, pre_selecionados, filename=temp_file.name)
                    temp_file.seek(0)
                    st.download_button(
                        label="Baixar Relat√≥rio Anal√≠tico em TXT",
                        data=temp_file.read(),
                        file_name="relatorio_analitico.txt",
                        mime="text/plain"
                    )

if __name__ == "__main__":
    main()