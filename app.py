# -*- coding: utf-8 -*-
"""app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lSTkoXFw57BsoQQd4cHxlclYQOvJM7cG
"""

import streamlit as st
import openai
import pdfplumber
import pandas as pd
import re
import unicodedata
from openpyxl.styles import Font, Alignment
import tempfile

st.set_page_config(page_title="Análise Automática de Propostas de Bombas", layout="wide")


# =================== FUNÇÕES DE EXTRAÇÃO E PROMPTS ===================
def extrair_texto_pdf(file):
    texto_total = ""
    with pdfplumber.open(file) as pdf:
        for pagina in pdf.pages:
            texto = pagina.extract_text()
            if texto:
                texto_total += texto + "\n"
    return texto_total

def prompt_lote1(texto_extraido):
    return f"""
A partir do texto extraído, extraia os seguintes dados da lista abaixo. A lista apresenta o nome da variável, o termo correspondente da variável no texto extraido em parênteses e a unidade da variável (caso o dado possuia unidade). Em alguns casos, o dado virá como "informar", nesses casos o valor extraido deverá ser "informar", assim como descrito no texto extraido.

- Fluido Bombeado (**Liquid type**).
- Característica do Fluido (**Additional liquid description**).
- Densidade do Fluido (**Fluid density**): Em kg/m3.
- Viscosidade (**Viscosity, rated**): Em cp.
- Pressão de Vapor (**Vapor pressure, rated**): Em bar.a.
- Diâmetro da maior partícula sólida (**Solids diameter, max**): Em mm.
- Concentração de sólidos por volume (**Solids concentration, by volume**): Em %.
- Temperatura de Operação (**Temperature, rated**): Em °C.
- Temperatura Máxima de Operação (**Temperature, max**): Em °C.
- Frequência Disponível no Campo (**Site Supply Frequency**): Em Hz.
- Vazão de Operação (**Flow, rated**): Em m³/h.
- Vazão Mínima Contínua Estável (**MCSF**): Em m3/h.
- Vazão no BEP (**Flow, best eff. Point**): Em m³/h.
- NPSH Disponível (**NPSH available,rated**): Em m.
- NPSH Requerido (**NPSH (3% head drop)**): Em m.

Retorne TODOS os parâmetros da lista, nesta ordem, mesmo se não forem encontrados (coloque "Não encontrado").
Use os nomes exatos da lista para a coluna 'Descrição'. Não pule NENHUM item.
O texto extraído do PDF é:
{texto_extraido}

| Descrição                          | Valor | Unidade |
|------------------------------------|-------|---------|
| Fluido Bombeado                    |       |    -    |
| Característica do Fluido           |       |    -    |
| Densidade do Fluido                |       | kg/m³   |
| Viscosidade                        |       | cP      |
| Pressão de Vapor                   |       | bar.a   |
| Diâmetro da maior partícula sólida |       | mm      |
| Concentração de sólidos por volume |       | %       |
| Temperatura de Operação            |       | °C      |
| Temperatura Máxima de Operação     |       | °C      |
| Frequência Disponível no Campo     |       | Hz      |
| Vazão de Operação                  |       | m³/h    |
| Vazão Mínima Contínua Estável      |       | m³/h    |
| Vazão no BEP                       |       | m³/h    |
| NPSH Disponível                    |       | m       |
| NPSH Requerido                     |       | m       |
"""

def prompt_lote2(texto_extraido):
    return f"""
A partir do texto extraído, extraia os seguintes dados da lista abaixo. A lista apresenta o nome da variável, o termo correspondente da variável no texto extraido em parênteses e a unidade da variável (caso o dado possua unidade). Em alguns casos, o dado virá como "informar", nesses casos o valor extraido deverá ser "informar", assim como descrito no texto extraido.

- AMT de Projeto (**Diferential Head, rated**): Em m.
- AMT do Rotor Máximo na Vazão de Projeto (**Head, maximum, rated diameter**): Em m.
- Margem de Shut-Off (**Head rise to shutoff**): %.
- Máxima Pressão de Operação da Voluta (**Maximum casing/bowl working pressure**): Em bar.g.
- Máxima Pressão de Operação admissível (**Maximum allowable working pressure**): Em bar.g.
- Máxima Pressão de Sucção admissível (**Maximum allowable suction pressure**): Em kg.cm2.g.
- Pessão do Teste Hidrostático (**Hydrostatic test pressure**): Em bar.g.
- Pressão de Sucção (**Suction Pressure**): Em kg/cm2.g.
- Pressão de Descarga de Operação (**Discharge Pressure, rated**): Em bar.g.
- Pressão Diferencial de Operação (**Differential pressure, rated**): Em bar.g.
- Rotação Constante ou Variável (**Fixed / Vabiable Speed**).
- Rotação do Motor (**Speed, driver, rated**):Em rpm.
- Rotação Selecionada (**Speed, rated**): Em rpm.
- Diâmetro Mínimo do Rotor (**Impeller diameter, minimum**): Em mm.
- Diâmetro Máximo do Rotor (**Impeller diameter, maximum**): Em mm.

Retorne TODOS os parâmetros da lista, nesta ordem, mesmo se não forem encontrados (coloque "Não encontrado").
Use os nomes exatos da lista para a coluna 'Descrição'. Não pule NENHUM item.
O texto extraído do PDF é:
{texto_extraido}

| Descrição                          | Valor | Unidade |
|------------------------------------|-------|---------|
| AMT de Projeto                     |       | m       |
| AMT do Rotor Máximo na Vazão de Projeto |       | m    |
| Margem de Shut-Off                 |       | %       |
| Máxima Pressão de Operação da Voluta |       | bar.g   |
| Máxima Pressão de Operação admissível|       | bar.g   |
| Máxima Pressão de Sucção admissível |       | kg.cm2.g |
| Pessão do Teste Hidrostático       |       | bar.g   |
| Pressão de Sucção                  |       | kg.cm2.g |
| Pressão de Descarga de Operação    |       | bar.g   |
| Pressão Diferencial de Operação    |       | bar.g   |
| Rotação Constante ou Variável      |       |  -      |
| Rotação do Motor                   |       | rpm     |
| Rotação Selecionada                |       | rpm     |
| Diâmetro Mínimo do Rotor           |       | mm      |
| Diâmetro Máximo do Rotor           |       | mm      |
"""

def prompt_lote3(texto_extraido):
    return f"""
A partir do texto extraído, extraia os seguintes dados da lista abaixo. A lista apresenta o nome da variável, o termo correspondente da variável no texto extraido em parênteses e a unidade da variável (caso o dado possua unidade). Em alguns casos, o dado virá como "informar", nesses casos o valor extraido deverá ser "informar", assim como descrito no texto extraido.

- Diâmetro Selecionado do Rotor (**Impeller diameter, rated**): Em mm.
- Eficiência da Bomba (**Efficiency**): Em %.
- Modelo de Bomba (**Pump Type**).
- Características adicionais da bomba (**Additional Pump Description**).
- Comprimento do Conjunto (**Length**): Em mm.
- Largura do Conjunto (**Width**): Em mm.
- Altura do Conjunto (**Hight**): Em mm.
- Diâmetro do Bocal de Sucção (**Suction Nozzle Size**): Em mm.
- Diâmetro do Bocal de Descarga (**Discharge Nozzle Size**): Em mm.
- Material da Carcaça (**Case / bowls**).
- Material do Rotor (**Impeller**).
- Material dos Aneis de Desgaste (**Case / Impeller Wear Rings**).
- Material do Eixo (**Shaft**).
- Tipo de Acoplamento (**Coupling**).
- Tipo de Motor (**Driver**).

Retorne TODOS os parâmetros da lista, nesta ordem, mesmo se não forem encontrados (coloque "Não encontrado").
Use os nomes exatos da lista para a coluna 'Descrição'. Não pule NENHUM item.
O texto extraído do PDF é:
{texto_extraido}

| Descrição                          | Valor | Unidade |
|------------------------------------|-------|---------|
| Diâmetro Selecionado do Rotor      |       | mm      |
| Eficiência da Bomba                |       |  %      |
| Modelo de Bomba                    |       | -       |
| Características adicionais da bomba|       | -       |
| Comprimento do Conjunto            |       | mm      |
| Largura do Conjunto                |       | mm      |
| Altura do Conjunto                 |       | mm      |
| Diâmetro do Bocal de Sucção        |       | mm      |
| Diâmetro do Bocal de Descarga      |       | mm      |
| Material da Carcaça                |       | -       |
| Material do Rotor                  |       | -       |
| Material dos Aneis de Desgaste     |       | -       |
| Material do Eixo                   |       | -       |
| Tipo de Acoplamento                |       | -       |
| Tipo de Motor                      |       | -       |
"""

def prompt_lote4(texto_extraido):
    return f"""
A partir do texto extraído, extraia os seguintes dados da lista abaixo. Em alguns casos, o dado virá como "informar", nesses casos o valor extraido deverá ser "informar", assim como descrito no texto extraido.

- Tensão do Motor (**Volts**): Em V.
- Fase do Motor (**Phase**).
- Frequência do Motor (**Frequency**): Em Hz.
- Potência Hidráulica (**Power, hydraulic**): Em kW.
- Potência Instalada (**Driver size**): Em kW.
- Potência Consumida (**Power, rated**): Em kW.
- Potência Absorvida (BHP) (**Power, maximum, rated diameter**): Em kW.
- Fator de Serviço (**Service Factor**).
- Grau de proteção (**Enclosure**).
- Peso da Bomba (**Pump**): Em kg.
- Peso do motor (**Driver**): Em kg.
- Peso da Base (**Baseplate**): Em kg.
- Peso do Conjunto (**Total Package**): Em kg.
- Preço (**Pump Price**): Em R$.
- Prazo de Entrega (**Estimated Delivery**): Em Dias

Retorne TODOS os parâmetros da lista, nesta ordem, mesmo se não forem encontrados (coloque "Não encontrado").
Use os nomes exatos da lista para a coluna 'Descrição'. Não pule NENHUM item.
O texto extraído do PDF é:
{texto_extraido}

| Descrição                          | Valor | Unidade |
|------------------------------------|-------|---------|
| Tensão do Motor                    |       | V       |
| Fase do Motor                      |       | -       |
| Frequência do Motor                |       | Hz      |
| Potência Hidráulica                |       | kW      |
| Potência Instalada                 |       | kW      |
| Potência Consumida                 |       | kW      |
| Potência Absorvida (BHP)           |       | kW      |
| Fator de Serviço                   |       | -       |
| Grau de proteção                   |       | -       |
| Peso da Bomba                      |       | kg      |
| Peso do motor                      |       | kg      |
| Peso da Base                       |       | kg      |
| Peso do Conjunto                   |       | kg      |
| Preço                              |       | R$      |
| Prazo de Entrega                   |       | Dias    |
"""

def analisar_texto_com_openai(texto_extraido):
    try:
        resposta_parte1 = openai.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "Você é um assistente técnico especializado em análise de propostas de bombas."},
                {"role": "user", "content": prompt_lote1(texto_extraido)}
            ],
            max_tokens=800,
            temperature=0
        )
        resposta_parte2 = openai.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "Você é um assistente técnico especializado em análise de propostas de bombas."},
                {"role": "user", "content": prompt_lote2(texto_extraido)}
            ],
            max_tokens=800,
            temperature=0
        )
        resposta_parte3 = openai.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "Você é um assistente técnico especializado em análise de propostas de bombas."},
                {"role": "user", "content": prompt_lote3(texto_extraido)}
            ],
            max_tokens=800,
            temperature=0
        )
        resposta_parte4 = openai.chat.completions.create(
            model="gpt-4",
            messages=[
                {"role": "system", "content": "Você é um assistente técnico especializado em análise de propostas de bombas."},
                {"role": "user", "content": prompt_lote4(texto_extraido)}
            ],
            max_tokens=800,
            temperature=0
        )
        dados_completos = (
            resposta_parte1.choices[0].message.content.strip() + "\n" +
            resposta_parte2.choices[0].message.content.strip() + "\n" +
            resposta_parte3.choices[0].message.content.strip() + "\n" +
            resposta_parte4.choices[0].message.content.strip()
        )
        return dados_completos
    except Exception as e:
        st.error(f"Erro ao processar texto com OpenAI: {e}")
        return "Erro na análise com OpenAI"

# -- PADRONIZAÇÕES BÁSICAS (só os essenciais para rodar) --
def padronizar_nome(descricao):
    PADRONIZAR = {
        "densidade do fluido": "Densidade do Fluido",
        "potência instalada": "Potência Instalada",
        "vazão mínima contínua estável": "Vazão Mínima Contínua Estável",
        # Inclua outras variações conforme aparecerem
    }
    return PADRONIZAR.get(descricao.strip(), descricao.strip())

def padronizar_unidade(unidade):
    PADRONIZAR_UNIDADE = {
        "kg/m3": "kg/m³",
        "kg / m3": "kg/m³",
        "kg/m³": "kg/m³",
        "cp": "cP",
        "bar.a": "bar.a",
        "m3/h": "m³/h",
        "m³/h": "m³/h",
        "bar": "bar",
        "rpm": "rpm",
        "mm": "mm",
        "kW": "kW",
        "%": "%",
        "-": "-",
    }
    return PADRONIZAR_UNIDADE.get(unidade.strip().replace(" ", ""), unidade.strip())

def normalizar(texto):
    texto = str(texto).strip().lower()
    texto = ''.join(c for c in unicodedata.normalize('NFD', texto) if unicodedata.category(c) != 'Mn')
    texto = re.sub(r'[^a-z0-9]', '', texto)
    return texto

# -- CONVERTE A TABELA MARKDOWN PARA DATAFRAME --
def converter_markdown_em_df(markdown_str):
    linhas = markdown_str.strip().split("\n")
    dataframes = []
    tabela_atual = []
    is_table_header = False
    for linha in linhas:
        if linha.strip().startswith("| Descrição") and "Valor" in linha and "Unidade" in linha:
            if tabela_atual:
                df_temp = criar_df_de_tabela(tabela_atual)
                if not df_temp.empty:
                    dataframes.append(df_temp)
                tabela_atual = []
            is_table_header = True
            tabela_atual.append(linha)
        elif is_table_header and re.match(r"^\|[- ]+\|[- ]+\|[- ]+\|$", linha.strip()):
            tabela_atual.append(linha)
        else:
            if "|" in linha:
                tabela_atual.append(linha)
    if tabela_atual:
        df_temp = criar_df_de_tabela(tabela_atual)
        if not df_temp.empty:
            dataframes.append(df_temp)
    if dataframes:
        df_final = pd.concat(dataframes, ignore_index=True)
        return df_final
    else:
        return pd.DataFrame()

def criar_df_de_tabela(linhas_tabela):
    if len(linhas_tabela) < 3:
        return pd.DataFrame()
    data_rows = []
    for row in linhas_tabela[2:]:
        partes = [p.strip() for p in row.split("|") if p.strip()]
        if len(partes) == 3:
            data_rows.append({
                "Descrição": partes[0],
                "Valor": partes[1],
                "Unidade": partes[2]
            })
    if data_rows:
        return pd.DataFrame(data_rows)
    else:
        return pd.DataFrame()

# -- PRÉ-PROCESSAMENTO DE CADA FORNECEDOR --
def processar_fornecedor(nome_arquivo, texto_extraido):
    dados_estruturados = analisar_texto_com_openai(texto_extraido)
    df_bruto = converter_markdown_em_df(dados_estruturados)
    df_bruto.columns = [c.strip().capitalize() for c in df_bruto.columns]
    if "Descrição" in df_bruto.columns and "Unidade" in df_bruto.columns and "Valor" in df_bruto.columns:
        df_bruto["Descrição"] = df_bruto["Descrição"].apply(lambda x: padronizar_nome(x.strip()))
        df_bruto["Unidade"] = df_bruto["Unidade"].apply(lambda x: padronizar_unidade(x.strip()))
        df_bruto["_desc_cmp"] = df_bruto["Descrição"].apply(normalizar)
        df_bruto["_und_cmp"] = df_bruto["Unidade"].apply(normalizar)
        df_bruto = df_bruto.drop_duplicates(subset=["_desc_cmp", "_und_cmp"], keep="first")
        df_bruto = df_bruto.drop(columns=["_desc_cmp", "_und_cmp"])
        df_bruto = df_bruto.set_index(["Descrição", "Unidade"])[["Valor"]]
        df_bruto.columns = [nome_arquivo]
        return df_bruto
    else:
        st.warning(f"[ERRO] Colunas esperadas não encontradas no DataFrame de {nome_arquivo}: {df_bruto.columns}")
        return None

def montar_tabela_com_secoes_multifornecedor(df, ordem_total=None, map_para_secao=None):
    if map_para_secao is None:
        map_para_secao = {
            "Fluido Bombeado": "DADOS DO FLUIDO",
            "Característica do Fluido": "DADOS DO FLUIDO",
            "Densidade do Fluido": "DADOS DO FLUIDO",
            "Viscosidade": "DADOS DO FLUIDO",
            "Pressão de Vapor": "DADOS DO FLUIDO",
            "Diâmetro da maior partícula sólida": "DADOS DO FLUIDO",
            "Concentração de sólidos por volume": "DADOS DO FLUIDO",
            "Frequência Disponível no Campo": "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO",
            "Temperatura de Operação": "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO",
            "Temperatura Máxima de Operação": "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO",
            "Pressão de Descarga de Operação": "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO",
            "Vazão de Operação": "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO",
            "AMT de Projeto": "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO",
            "Vazão no BEP": "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO",
            "Vazão Mínima Contínua Estável": "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO",
            "NPSH Disponível": "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO",
            "NPSH Requerido": "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO",
            "Pressão de Sucção": "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO",
            "Pressão Diferencial de Operação": "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO",
            "Máxima Pressão de Sucção admissível": "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO",
            "Máxima Pressão de Operação admissível": "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO",
            "Máxima Pressão de Operação da Voluta": "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO",
            "Pessão do Teste Hidrostático": "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO",
            "Margem de Shut-Off": "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO",
            "Rotação Constante ou Variável": "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO",
            "Rotação do Motor": "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO",
            "Rotação Selecionada": "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO",
            "Diâmetro Selecionado do Rotor": "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO",
            "Diâmetro Mínimo do Rotor": "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO",
            "Diâmetro Máximo do Rotor": "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO",
            "AMT do Rotor Máximo na Vazão de Projeto": "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO",
            "Eficiência da Bomba": "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO",
            "Modelo de Bomba": "CARACTERÍSTICAS CONSTRUTIVAS",
            "Comprimento do Conjunto": "CARACTERÍSTICAS CONSTRUTIVAS",
            "Características adicionais da bomba": "CARACTERÍSTICAS CONSTRUTIVAS",
            "Largura do Conjunto": "CARACTERÍSTICAS CONSTRUTIVAS",
            "Altura do Conjunto": "CARACTERÍSTICAS CONSTRUTIVAS",
            "Diâmetro do Bocal de Sucção": "CARACTERÍSTICAS CONSTRUTIVAS",
            "Diâmetro do Bocal de Descarga": "CARACTERÍSTICAS CONSTRUTIVAS",
            "Tipo de Motor": "MOTOR ELÉTRICO",
            "Fator de Serviço": "MOTOR ELÉTRICO",
            "Tensão do Motor": "MOTOR ELÉTRICO",
            "Fase do Motor": "MOTOR ELÉTRICO",
            "Frequência do Motor": "MOTOR ELÉTRICO",
            "Potência Hidráulica": "MOTOR ELÉTRICO",
            "Potência Consumida": "MOTOR ELÉTRICO",
            "Potência Instalada": "MOTOR ELÉTRICO",
            "Potência Absorvida (BHP)": "MOTOR ELÉTRICO",
            "Grau de proteção": "MOTOR ELÉTRICO",
            "Tipo de Acoplamento": "TRANSMISSÃO",
            "Material da Carcaça": "MATERIAL DE CONSTRUÇÃO",
            "Material do Rotor": "MATERIAL DE CONSTRUÇÃO",
            "Material dos Aneis de Desgaste": "MATERIAL DE CONSTRUÇÃO",
            "Material do Eixo": "MATERIAL DE CONSTRUÇÃO",
            "Peso da Bomba": "PESOS",
            "Peso do motor": "PESOS",
            "Peso da Base": "PESOS",
            "Peso do Conjunto": "PESOS",
            "Preço": "FINANCEIRO",
            "Prazo de Entrega": "FINANCEIRO"
        }
    secoes = [
        "DADOS DO FLUIDO",
        "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO",
        "CARACTERÍSTICAS CONSTRUTIVAS",
        "MATERIAL DE CONSTRUÇÃO",
        "TRANSMISSÃO",
        "MOTOR ELÉTRICO",
        "PESOS",
        "FINANCEIRO"
    ]
    col_base = ['Descrição', 'Unidade']
    col_forn = [c for c in df.columns if c not in col_base]
    linhas_finais = []
    for secao in secoes:
        linhas_finais.append([secao, '', *['']*len(col_forn)])
        for idx, row in df.iterrows():
            desc = row['Descrição']
            if map_para_secao.get(desc) == secao:
                valores = row.tolist()
                linhas_finais.append(valores)
    return pd.DataFrame(linhas_finais, columns=col_base + col_forn)

# ======================================
#  FUNÇÃO PARA SALVAR EM EXCEL COM FORMATAÇÃO
# ======================================
def salvar_em_excel_formatado(df_final, nome_arquivo_excel="dados_extraidos.xlsx"):
    with pd.ExcelWriter(nome_arquivo_excel, engine="openpyxl") as writer:
        df_final.to_excel(writer, index=False, sheet_name="Dados")
        workbook = writer.book
        worksheet = writer.sheets["Dados"]
        secoes = ["DADOS DO FLUIDO", "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO", "CARACTERÍSTICAS CONSTRUTIVAS",
                  "MATERIAL DE CONSTRUÇÃO", "TRANSMISSÃO", "MOTOR ELÉTRICO", "PESOS", "FINANCEIRO"]
        for row in worksheet.iter_rows(min_row=2, max_row=worksheet.max_row, min_col=1, max_col=3):
            cell = row[0]
            if cell.value in secoes:
                worksheet.merge_cells(start_row=cell.row, start_column=1, end_row=cell.row, end_column=3)
                cell.font = Font(bold=True)
                cell.alignment = Alignment(horizontal="center", vertical="center")
    return nome_arquivo_excel

def salvar_em_excel_final(dados_estruturados):
    df_bruto = converter_markdown_em_df(dados_estruturados)
    df_bruto.columns = [c.strip().capitalize() for c in df_bruto.columns]
    print(f"\nColunas do DataFrame extraído ({nome_arquivo}):", df_bruto.columns)
    if df_bruto.empty:
        print("Não foi possível converter as tabelas retornadas em DataFrame.")
        print(dados_estruturados)
        return
    df_final = montar_tabela_com_secoes(df_bruto)
    if not df_final.empty:
        salvar_em_excel_formatado(df_final)
    else:
        print("O DataFrame final está vazio. Verifique se os parâmetros foram encontrados.")

def is_number(s):
    try:
        # Troca vírgula por ponto, remove espaços
        return float(str(s).replace(",", ".").replace(" ", ""))
    except:
        return None

def checar_atendimento(df, col_requisitado):
    cols = list(df.columns)
    colunas_proponentes = [col for col in cols if col not in ["Descrição", "Unidade", col_requisitado]]

    # Lista com nomes das seções (os títulos)
    secoes = [
        "DADOS DO FLUIDO",
        "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO",
        "CARACTERÍSTICAS CONSTRUTIVAS",
        "MATERIAL DE CONSTRUÇÃO",
        "TRANSMISSÃO",
        "MOTOR ELÉTRICO",
        "PESOS",
        "FINANCEIRO"
    ]

    for col_prop in colunas_proponentes:
        col_check = f"Atendimento {col_prop}"
        resultados = []
        for i, row in df.iterrows():
            # Pula linha se for seção/título
            if row["Descrição"] in secoes:
                resultados.append("")
                continue

            req = str(row[col_requisitado]).strip().lower()
            prop = str(row[col_prop]).strip().lower()
            if req == "informar":
                resultados.append("NA")
                continue

            req_num = is_number(req)
            prop_num = is_number(prop)
            if (req_num is not None) and (prop_num is not None):
                if abs(req_num - prop_num) < 1e-6:
                    resultados.append("OK")
                else:
                    resultados.append("NOK")
            else:
                if req == prop:
                    resultados.append("OK")
                elif req.replace(",", ".").replace(" ", "") == prop.replace(",", ".").replace(" ", ""):
                    resultados.append("OK")
                else:
                    resultados.append("NOK")
        df[col_check] = resultados
    return df

# ======================================
#  FUNÇÃO PARA AVALIAR PROPONENTES
# ======================================


def relatorio_analitico_fornecedores(df_final, col_requisitado):
    secoes = [
        "DADOS DO FLUIDO", "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO", "CARACTERÍSTICAS CONSTRUTIVAS",
        "MATERIAL DE CONSTRUÇÃO", "TRANSMISSÃO", "MOTOR ELÉTRICO", "PESOS", "FINANCEIRO"
    ]
    fornecedores = [
        col for col in df_final.columns
        if col not in ["Descrição", "Unidade", col_requisitado] and not col.startswith("Atendimento")
    ]
    relatorios = {}
    desclassificados = []

    def valor(desc, col):
        try:
            return str(df_final.loc[df_final['Descrição'] == desc, col].values[0]).strip()
        except:
            return ""

    # 1. NPSH: Desclassificação e comparação com margem
    npsh_req = valor("NPSH Requerido", col_requisitado)
    npsh_req_num = is_number(npsh_req)
    margem_npsh = 1.0  # valor em metros

    for f in fornecedores:
        npsh = valor("NPSH Disponível", f)
        npsh_num = is_number(npsh)
        if npsh_num is not None and npsh_req_num is not None:
            if npsh_num < npsh_req_num + margem_npsh:
                desclassificados.append((f, f"NPSH disponível inferior ao requerido + margem de segurança ({margem_npsh} m); risco de cavitação."))

    classificados = [f for f in fornecedores if f not in [d[0] for d in desclassificados]]


    # 2. Reprova bombas sem acoplamento magnético caso haja sólidos no fluido
    concentracao_solidos = valor("Concentração de sólidos por volume", col_requisitado)
    diametro_solido = valor("Diâmetro da maior partícula sólida", col_requisitado)

    # Considera sólidos presentes se concentração > 0 ou diâmetro > 0
    solidos_presentes = False
    try:
        conc = float(str(concentracao_solidos).replace(",", "."))
        diam = float(str(diametro_solido).replace(",", "."))
        solidos_presentes = (conc > 0) or (diam > 0)
    except:
        pass

    for f in classificados[:]:  # Copia da lista para evitar problemas ao remover
        acoplamento = valor("Tipo de Acoplamento", f).lower()
        if solidos_presentes and ("magnét" not in acoplamento):
            desclassificados.append((f, "Proposta não possui acoplamento magnético, obrigatório devido à presença de sólidos no fluido."))
            classificados.remove(f)

    # 2. Relatório analítico
    for f in fornecedores:
        rel = []
        if f in [d[0] for d in desclassificados]:
            motivo = [motivo for ff, motivo in desclassificados if ff == f][0]
            rel.append(f"**Desclassificado:** {motivo}")
            relatorios[f] = rel
            continue

        # Potência instalada >= Potência absorvida (BHP)
        pot_inst = is_number(valor("Potência Instalada", f))
        pot_bhp = is_number(valor("Potência Absorvida (BHP)", f))
        if pot_inst is not None and pot_bhp is not None:
            if pot_inst < pot_bhp:
                rel.append("⚠️ Potência instalada inferior à absorvida. Isso pode resultar em sobrecarga e falha do motor. **Recomenda-se revisar para evitar riscos operacionais.**")
            else:
                rel.append("✔️ Potência instalada atende à absorvida.")
        else:
            rel.append("⚠️ Potência instalada ou absorvida não informada. **Verifique se os dados estão completos para garantir dimensionamento adequado.**")

        # Eficiência
        eficiencia = is_number(valor("Eficiência da Bomba", f))
        ef_max = max([is_number(valor("Eficiência da Bomba", ff)) for ff in classificados if is_number(valor("Eficiência da Bomba", ff)) is not None] or [0])
        if eficiencia is not None:
            if eficiencia == ef_max:
                rel.append(f"✔️ Maior eficiência ({eficiencia}%).")
            elif eficiencia > 0:
                rel.append(f"Eficiência: {eficiencia}% (menor que a máxima: {ef_max}%). **Considere o impacto no consumo energético da planta.**")
            else:
                rel.append("⚠️ Eficiência não informada. **A eficiência influencia diretamente o custo operacional.**")

        # Escorregamento motor elétrico
        rot_selecionada = is_number(valor("Rotação Selecionada", f))
        rot_motor = is_number(valor("Rotação do Motor", f))
        if rot_selecionada and rot_motor:
            if rot_selecionada >= rot_motor:
                rel.append("⚠️ A rotação selecionada da bomba é igual ou superior à rotação do motor. Isso indica ausência de margem de escorregamento, podendo causar perda de torque e operação inadequada do motor elétrico de indução. **Recomenda-se sempre especificar rotação da bomba inferior à do motor (por exemplo, motor: 1800 rpm, bomba: 1745 rpm).**")

        # Material de construção
        material = valor("Material da Carcaça", f).lower()
        if any(sub in material for sub in ["ferro fundido", "cast iron"]):
            rel.append("⚠️ Bomba apresenta ferro fundido: esse material pode ser suscetível à corrosão dependendo do fluido bombeado. **Avalie a compatibilidade com o processo e o risco de falha prematura.**")
        elif any(sub in material for sub in ["carbon steel", "aço carbono"]):
            rel.append("⚠️ Bomba apresenta aço carbono: pode ser propenso à corrosão em ambientes agressivos. **Verifique se a seleção do material está adequada ao fluido.**")
        elif material == "" or material is None:
            rel.append("⚠️ Material da carcaça não informado. **A ausência dessa informação dificulta a avaliação de durabilidade e riscos.**")

        # Acoplamento magnético / selo / gaxeta
        MAP_ACOPLAMENTO = {
            "mechanical seal": "selo mecânico",
            "seal": "selo mecânico",
            "selo mecânico": "selo mecânico",
            "selo mecanico": "selo mecânico",
            "gaxeta": "gaxeta",
            "packing": "gaxeta",
            "magnetic coupling": "acoplamento magnético",
            "acoplamento magnético": "acoplamento magnético",
            "magnetico": "acoplamento magnético",
            "direct": "acoplamento direto",
            "direct coupling": "acoplamento direto",
        }

        def padronizar_acoplamento(valor):
            valor_norm = valor.lower().strip()
            for k in MAP_ACOPLAMENTO:
                if k in valor_norm:
                    return MAP_ACOPLAMENTO[k]
            return valor_norm  # Se não encontrar, retorna o original normalizado

        # No trecho de geração dos alertas:
        acoplamento_raw = valor("Tipo de Acoplamento", f)
        acoplamento = padronizar_acoplamento(acoplamento_raw)

        if acoplamento == "acoplamento magnético":
            rel.append("✔️ Acoplamento magnético: solução recomendada para aplicações críticas, especialmente em fluidos tóxicos, caros ou com sólidos. **Garante estanqueidade e reduz manutenção.**")
        elif acoplamento == "selo mecânico":
            rel.append("⚠️ Selo mecânico: opção intermediária. **Pode exigir manutenção periódica e deve ser avaliado quanto à adequação ao tipo de fluido e presença de sólidos.**")
        elif acoplamento == "gaxeta":
            rel.append("⚠️ Utiliza gaxetas: esse sistema pode permitir vazamentos e exige manutenção frequente. **Recomenda-se avaliar riscos de segurança, ambientais e de custo operacional.**")
        elif acoplamento:  # Não vazio, mas desconhecido
            rel.append(f"⚠️ Tipo de acoplamento não usual: {acoplamento_raw}. **Verifique se atende aos requisitos de confiabilidade e manutenção da planta.**")
        else:
            rel.append("⚠️ Tipo de acoplamento não informado. **Essa informação é essencial para avaliar riscos de operação e manutenção.**")

        # Preço da bomba
        preco = is_number(valor("Preço", f))
        if preco is not None:
            menores = [is_number(valor("Preço", ff)) for ff in classificados if is_number(valor("Preço", ff)) is not None]
            if preco == min(menores):
                rel.append("✔️ Preço mais barato.")
            elif preco == max(menores):
                rel.append("⚠️ Preço mais caro. **Avalie se os diferenciais técnicos justificam o investimento maior.**")
        else:
            rel.append("⚠️ Preço não informado. **A ausência desse dado impede a análise de custo-benefício.**")

        # Prazo de entrega
        prazo = is_number(valor("Prazo de Entrega", f))
        menores_prazo = [is_number(valor("Prazo de Entrega", ff)) for ff in classificados if is_number(valor("Prazo de Entrega", ff)) is not None]
        if prazo is not None:
            if prazo == min(menores_prazo):
                rel.append("✔️ Menor prazo de entrega.")
            elif prazo == max(menores_prazo):
                rel.append("⚠️ Maior prazo de entrega. **Considere o impacto no cronograma do projeto.**")
        else:
            rel.append("⚠️ Prazo de entrega não informado. **Verifique para garantir que atenda aos requisitos do projeto.**")

        # Frequência local vs motor
        freq_local = is_number(valor("Frequência Disponível no Campo", col_requisitado))
        freq_motor = is_number(valor("Frequência do Motor", f))
        if freq_local and freq_motor:
            if freq_local == freq_motor:
                rel.append("✔️ Frequência do motor compatível com o local.")
            else:
                rel.append(f"⚠️ Frequência do motor ({freq_motor}) diferente da disponível no local ({freq_local}). **Isso pode impedir o funcionamento adequado do equipamento. Avalie a necessidade de ajustes.**")
        else:
            rel.append("⚠️ Frequência do motor/local não informada. **Verifique essa compatibilidade para evitar problemas de partida e funcionamento.**")

        # Vazão operação/BEP entre 0,8 e 1,1
        vazao_op = is_number(valor("Vazão de Operação", f))
        vazao_bep = is_number(valor("Vazão no BEP", f))
        if vazao_op and vazao_bep:
            relacao = vazao_op / vazao_bep
            if 0.8 <= relacao <= 1.1:
                rel.append(f"✔️ Relação vazão de operação/BEP adequada ({relacao:.2f}).")
            else:
                rel.append(f"⚠️ Relação vazão/BEP fora do ideal ({relacao:.2f}). **Operar distante do BEP pode causar vibração, ruído e desgaste prematuro. Avalie o impacto para seu processo.**")
        else:
            rel.append("⚠️ Vazão de operação ou BEP não informada. **Impossível avaliar o ponto de operação ótimo.**")

       # Análise do volume do conjunto (menor volume é positivo)
        def volume_conjunto(f):
            try:
                comp = is_number(valor("Comprimento do Conjunto", f))
                larg = is_number(valor("Largura do Conjunto", f))
                alt = is_number(valor("Altura do Conjunto", f))
                if comp and larg and alt:
                    return comp * larg * alt
            except:
                pass
            return None

        # Calcule volumes para todos os fornecedores
        volumes = {ff: volume_conjunto(ff) for ff in fornecedores if volume_conjunto(ff) is not None}
        if volumes and f in volumes:
            if volumes[f] == min(volumes.values()):
                rel.append("✔️ Equipamento mais compacto (menor volume total). **Facilita a instalação, reduz o espaço ocupado na planta e pode simplificar o layout.**")
            elif volumes[f] == max(volumes.values()):
                rel.append("⚠️ Equipamento de maior volume entre as propostas. **Pode dificultar a integração ao layout existente e aumentar custos indiretos de infraestrutura.**")


        # Análise do peso do conjunto (menor peso é positivo)
        pesos = {ff: is_number(valor("Peso do Conjunto", ff)) for ff in fornecedores if is_number(valor("Peso do Conjunto", ff)) is not None}
        if pesos and f in pesos:
            if pesos[f] == min(pesos.values()):
                rel.append("✔️ Equipamento mais leve. **Pode facilitar o transporte, içamento e instalação, além de reduzir esforços na estrutura de suporte.**")
            elif pesos[f] == max(pesos.values()):
                rel.append("⚠️ Equipamento mais pesado entre as propostas. **Exige atenção à estrutura de suporte e pode aumentar custos logísticos.**")

        # Vazão mínima contínua estável
        vazao_min_req = is_number(valor("Vazão Mínima Contínua Estável", col_requisitado))
        vazao_min = is_number(valor("Vazão Mínima Contínua Estável", f))
        if vazao_min_req and vazao_min:
            if vazao_min <= vazao_min_req:
                rel.append("✔️ Vazão mínima contínua atende ao especificado.")
            else:
                rel.append("⚠️ Vazão mínima contínua superior ao especificado. **Pode dificultar a operação em baixas vazões. Avalie riscos de superaquecimento ou cavitação.**")
        elif vazao_min is None:
            rel.append("⚠️ Vazão mínima contínua não informada. **Importante verificar para garantir operação segura em baixa carga.**")

        # Margem de shut-off (em %)
        shut_off = is_number(valor("Margem de Shut-Off", f))
        if shut_off:
            if 10 <= shut_off <= 20:
                rel.append("✔️ Margem de shut-off adequada (10-20%).")
            else:
                rel.append(f"⚠️ Margem de shut-off fora do ideal ({shut_off}%). **Margem inadequada pode aumentar o risco de sobrepressão ou limitar o range operacional.**")
        else:
            rel.append("⚠️ Margem de shut-off não informada. **Impossível avaliar flexibilidade e segurança contra sobrepressão.**")

        # Materiais dos componentes principais
        for comp, desc in [("Material do Rotor", "rotor"), ("Material do Eixo", "eixo"), ("Material dos Aneis de Desgaste", "anéis de desgaste")]:
            material = valor(comp, f).lower()
            if any(m in material for m in ["inox", "stainless", "duplex", "bronze"]):
                continue  # Não faz alerta se for nobre
            elif any(m in material for m in ["ferro fundido", "cast iron", "carbon steel", "aço carbono"]):
                rel.append(f"⚠️ {desc.title()} com material propenso à corrosão ({material}). **Avalie a durabilidade em função do fluido e ambiente de operação.**")
            elif not material:
                rel.append(f"⚠️ Material do {desc} não informado. **Dificulta a avaliação de vida útil e confiabilidade.**")

        # Flexibilidade de operação
        velocidade = valor("Rotação Constante ou Variável", f).lower()
        if "variable" in velocidade or "variável" in velocidade:
            rel.append("✔️ Flexibilidade de operação: utiliza inversor de frequência. **Permite ajuste fino do ponto de operação, facilitando adaptação a variações de demanda.**")
        elif "fixed" in velocidade or "constante" in velocidade:
            rel.append("⚠️ Velocidade fixa: não utiliza inversor de frequência. **Isso reduz a flexibilidade operacional, pois a bomba só pode trabalhar em um ponto de operação. Avalie se a operação em diferentes regimes é necessária no seu processo.**")
        elif not velocidade:
            rel.append("⚠️ Informação de velocidade variável/constante não encontrada. **Verifique essa característica para entender a capacidade de ajuste operacional.**")

        # AMT rotor máximo/AMT projeto > 1,10
        amt_max = is_number(valor("AMT do Rotor Máximo na Vazão de Projeto", f))
        amt_proj = is_number(valor("AMT de Projeto", f))
        if amt_max and amt_proj:
            relacao = amt_max / amt_proj
            if relacao > 1.10:
                rel.append(f"✔️ AMT máximo/AMT projeto = {relacao:.2f} (>1,10). **Boa margem para ajustes futuros e usinagem de rotor.**")
            else:
                rel.append(f"⚠️ AMT máximo/AMT projeto abaixo do ideal ({relacao:.2f}). **Pode limitar a capacidade de ajuste do ponto de operação no futuro.**")
        else:
            rel.append("⚠️ AMT máximo ou de projeto não informado. **Verifique para avaliar a flexibilidade de operação.**")

        # Potência Instalada/Potência Consumida = Fator de serviço
        pot_cons = is_number(valor("Potência Consumida", f))
        fator_serv = is_number(valor("Fator de Serviço", f))
        if pot_inst and pot_cons and fator_serv:
            relacao = pot_inst / pot_cons
            if abs(relacao - fator_serv) < 0.05:
                rel.append(f"✔️ Potência instalada/consumida ≈ Fator de serviço ({relacao:.2f}).")
            else:
                rel.append(f"⚠️ Potência instalada/consumida ({relacao:.2f}) diferente do fator de serviço especificado ({fator_serv}). **Reveja para garantir margem de segurança adequada.**")
        else:
            rel.append("⚠️ Potência instalada, consumida ou fator de serviço não informado. **Verifique todos os parâmetros para validar o dimensionamento elétrico.**")

        # Tipo de motor
        tipo_motor = valor("Tipo de Motor", f).lower()
        if "combustão" in tipo_motor or "diesel" in tipo_motor or "gasolina" in tipo_motor or "combustion" in tipo_motor:
            rel.append("⚠️ Motor a combustão: só é recomendado para bombas de incêndio. **Avalie se há justificativa técnica para uso em outras aplicações.**")

        # Identifique a opção com menor potência consumida
        potencias = {ff: is_number(valor("Potência Consumida", ff)) for ff in fornecedores if is_number(valor("Potência Consumida", ff)) is not None}
        if potencias and f in potencias:
            if potencias[f] == min(potencias.values()):
                rel.append("✔️ Menor consumo de energia elétrica. **Pode resultar em menor custo operacional ao longo do tempo.**")

        relatorios[f] = rel

    # Pré-seleção final: só classificados, priorizando eficiência, prazo, preço, etc.
    pre_selecionados = [f for f in classificados][:3]

    return relatorios, desclassificados, pre_selecionados

# Para exibir relatório
def imprimir_relatorio(relatorios, desclassificados, pre_selecionados):
    print("\n====== RELATÓRIO ANALÍTICO DOS FORNECEDORES ======\n")
    for f, pontos in relatorios.items():
        positivos = []
        negativos = []
        for ponto in pontos:
            # Ajuste os critérios de acordo com seus ícones/frases
            if ponto.startswith("✔️") or ponto.startswith("✅") or "menor consumo" in ponto.lower() or "maior eficiência" in ponto.lower() or "preço mais barato" in ponto.lower() or "menor prazo" in ponto.lower() or "potência instalada atende" in ponto.lower():
                positivos.append(ponto)
            else:
                negativos.append(ponto)
        print(f"\nFornecedor: {f}")
        # Primeiro pontos positivos
        for p in positivos:
            print(" -", p)
        # Depois pontos negativos
        for p in negativos:
            print(" -", p)
    print("\n**Desclassificados:**")
    for f, motivo in desclassificados:
        print(f" - {f}: {motivo}")
    print("\n**Pré-selecionados:**", ", ".join(pre_selecionados))

# Salvar relatório em txt

def salvar_relatorio_txt(relatorios, desclassificados, pre_selecionados, filename="relatorio_analitico.txt"):
    with open(filename, "w", encoding="utf-8") as f:
        f.write("====== RELATÓRIO ANALÍTICO DOS FORNECEDORES ======\n\n")
        for fornecedor, pontos in relatorios.items():
            positivos = []
            negativos = []
            for ponto in pontos:
                if ponto.startswith("✔️") or ponto.startswith("✅") or "menor consumo" in ponto.lower() or "maior eficiência" in ponto.lower() or "preço mais barato" in ponto.lower() or "menor prazo" in ponto.lower() or "potência instalada atende" in ponto.lower():
                    positivos.append(ponto)
                else:
                    negativos.append(ponto)
            f.write(f"Fornecedor: {fornecedor}\n")
            for p in positivos:
                f.write(f" - {p}\n")
            for p in negativos:
                f.write(f" - {p}\n")
            f.write("\n")
        f.write("**Desclassificados:**\n")
        for fdesc, motivo in desclassificados:
            f.write(f" - {fdesc}: {motivo}\n")
        f.write("\n**Pré-selecionados:** " + ", ".join(pre_selecionados) + "\n")
    print(f"Relatório salvo em {filename}")


# =================== APP PRINCIPAL ===================
def main():
    st.title("Análise Inteligente de Propostas de Bombas")
    st.write("Faça upload dos PDFs de propostas e receba a planilha comparativa com relatório analítico.")

    openai_key = st.sidebar.text_input("API Key da OpenAI (gpt-4)", type="password")
    uploaded_files = st.file_uploader("Selecione os arquivos PDF das propostas", type=["pdf"], accept_multiple_files=True)

    if not openai_key:
        st.warning("Insira sua API Key da OpenAI para continuar.", icon="⚠️")
        st.stop()
    openai.api_key = openai_key

    if uploaded_files:
        st.info("Processando PDFs...", icon="🔄")
        dfs_fornecedores = []
        nomes_fornecedores = []
        nome_arquivo_requisitado = None
        for file in uploaded_files:
            nome_arquivo = file.name.replace(".pdf", "")
            texto_extraido = extrair_texto_pdf(file)
            with st.expander(f"Texto extraído de {nome_arquivo}"):
                st.write(texto_extraido)
            df_fornecedor = processar_fornecedor(nome_arquivo, texto_extraido)
            if df_fornecedor is not None:
                dfs_fornecedores.append(df_fornecedor)
                nomes_fornecedores.append(nome_arquivo)
                if nome_arquivo.lower() == "requisitado":
                    nome_arquivo_requisitado = nome_arquivo

        if dfs_fornecedores:
            df_final = pd.concat(dfs_fornecedores, axis=1)
            df_final = df_final.reset_index()
            st.dataframe(df_final)

            st.subheader("Baixe a tabela Excel final:")
            nome_arquivo_excel = "dados_extraidos.xlsx"
            with pd.ExcelWriter(nome_arquivo_excel, engine="openpyxl") as writer:
                df_final.to_excel(writer, index=False, sheet_name="Dados")
                workbook = writer.book
                worksheet = writer.sheets["Dados"]
                secoes = [
                    "DADOS DO FLUIDO", "CONDIÇÕES DE OPERAÇÃO E DESEMPENHO",
                    "CARACTERÍSTICAS CONSTRUTIVAS", "MATERIAL DE CONSTRUÇÃO",
                    "TRANSMISSÃO", "MOTOR ELÉTRICO", "PESOS", "FINANCEIRO"
                ]
                for row in worksheet.iter_rows(min_row=2, max_row=worksheet.max_row, min_col=1, max_col=3):
                    cell = row[0]
                    if cell.value in secoes:
                        worksheet.merge_cells(start_row=cell.row, start_column=1, end_row=cell.row, end_column=3)
                        cell.font = Font(bold=True)
                        cell.alignment = Alignment(horizontal="center", vertical="center")
            with open(nome_arquivo_excel, "rb") as f:
                st.download_button("Baixar Excel formatado", data=f, file_name=nome_arquivo_excel)

            # ===== Relatório Analítico =====
            st.subheader("Relatório Analítico Técnico")
            if not nome_arquivo_requisitado:
                nome_arquivo_requisitado = nomes_fornecedores[0]  # fallback

            col_requisitado = nome_arquivo_requisitado
            if st.button("Gerar Relatório Analítico"):
                df_final2 = checar_atendimento(df_final, col_requisitado=col_requisitado)
                relatorios, desclassificados, pre_selecionados = relatorio_analitico_fornecedores(df_final2, col_requisitado)
                for f, pontos in relatorios.items():
                    st.markdown(f"**Fornecedor: {f}**")
                    for p in pontos:
                        if p.startswith("✔️"):
                            st.success(p)
                        elif p.startswith("⚠️"):
                            st.warning(p)
                        else:
                            st.write(p)
                if desclassificados:
                    st.warning("**Desclassificados:**")
                    for f, motivo in desclassificados:
                        st.write(f"- {f}: {motivo}")
                if pre_selecionados:
                    st.info("**Pré-selecionados:** " + ", ".join(pre_selecionados))

                with tempfile.NamedTemporaryFile("w+", delete=False, suffix=".txt", encoding="utf-8") as temp_file:
                    salvar_relatorio_txt(relatorios, desclassificados, pre_selecionados, filename=temp_file.name)
                    temp_file.seek(0)
                    st.download_button(
                        label="Baixar Relatório Analítico em TXT",
                        data=temp_file.read(),
                        file_name="relatorio_analitico.txt",
                        mime="text/plain"
                    )

if __name__ == "__main__":
    main()